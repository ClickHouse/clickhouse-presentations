<!DOCTYPE html>
<html lang="en">
<head>
    <title>Query Profiler: The Hard Way</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="shower/themes/yandex/styles/screen-16x9.css">

    <style type="text/css">
         code { display: block; white-space: pre; background-color: #EEE; }
         p.cloud { text-align: center; line-height: 2; }
         p.cloud span { font-size: 28pt; color: gray; padding: 0 20px 0 20px; white-space: nowrap; }
    </style>
</head>
<body class="shower list">
    <header class="caption">
        <h1>Query Profiler: The Hard Way</h1>
    </header>

    <section class="slide" id="cover">
        <h1 style="margin-top: 150px; font-size: 36pt; line-height: 150%;">Query Profiler: The Hard Way</h1>
    </section>

<section class="slide">
<h2>About Me</h2>
<p>Alexey &mdash; ClickHouse developer.</p>
<p>ClickHouse &mdash; analytical DBMS.</p>
<p>Main product feature<br/>&mdash; high query processing speed.</p>
</section>

<section class="slide">
<h2>Trivial Facts</h2>
<p>and basic principles.</p>
</section>

<section class="slide">
<h2>Trivial Facts</h2>
<p>To improve something &mdash; you need to measure it.</p>
<p>Break it down into components and measure the contribution of each.</p>
<p>Find out what is the main bottleneck of the system.</p>
<p style="margin-top: 2em;">&mdash; a profiler can be used for this.</p>
</section>


<section class="slide">
<img style="width: 100%; margin-top: 5%;" src="pictures/perf.png" />
</section>

<section class="slide">
<img style="height: 90%;" src="pictures/pprof.gif" />
</section>

<section class="slide">
<img style="width: 100%; margin-top: 5%;" src="pictures/kcachegrind.png" />
</section>

<section class="slide">
<img style="width: 100%; margin-top: 5%;" src="pictures/flamegraph.svg" />
</section>


<section class="slide">
<h2>What Types of Profilers Exist?</h2>
<p><b>Low-level</b>:</p>
<p>&mdash; which functions in my code spend more time?</p>
<p>(of course in <b>memcpy</b>... or <b>malloc</b>)</p>
<p style="margin-top: 2em;"><b>High-level</b>:</p>
<p>&mdash; which data transformation takes more time?</p>
<p>(JOIN? Sorting? Aggregation?)</p>
</section>

<section class="slide">
<h2>Trivial Example</h2>
<p>The profiler shows that most time<br/>is spent executing <b>memcpy</b>.</p>
<p>Need to optimize this function?</p>

<p style="margin-top: 2em;">Yes, ClickHouse has optimized memcpy!</p>
<p>Actually, even several...</p>
<p>&mdash; &laquo;Chinese&raquo; memcpy;</p>
<p>&mdash; memcpy for gathering short memory chunks:<br/>
memcpySmallAllowReadWriteOverflow15</p>
</section>

<section class="slide">
<h2>Trivial Example</h2>
<p>The profiler shows that most time<br/>is spent executing <b>memcpy</b>.</p>
<p>Need to optimize this function?</p>

<p style="margin-top: 2em;">But usually we just need to call it less:</p>
<code>std::vector&lt;int> vec;
for (int i = 0; i &lt; n; ++i)
    vec.push_back(i); // <b style="color: red;">memcpy</b></code>
</section>

<section class="slide">
<h2>Obvious Example</h2>
<p>The profiler shows that most time<br/>is spent executing <b>memcpy</b>.</p>
<p>Need to optimize this function?</p>

<p style="margin-top: 2em;">But usually we just need to call it less:</p>
<code>std::vector&lt;int> vec;
vec.reserve(n);
for (int i = 0; i &lt; n; ++i)
    vec.push_back(i);</code>
</section>

<section class="slide">
<h2>Obvious Example</h2>
<p>The profiler shows that most time<br/>is spent executing <b>memcpy</b>.</p>
<p>Need to optimize this function?</p>

<p style="margin-top: 2em;">But usually we just need to call it less:</p>
<code>std::vector&lt;int> vec;
vec.resize(n); // <b style="color: red;">memset</b>
for (int i = 0; i &lt; n; ++i)
    vec[i] = i;</code>
</section>

<section class="slide">
<h2>Banal Example</h2>
<p>The profiler shows that most time<br/>is spent executing <b>memcpy</b>.</p>
<p>Need to optimize this function?</p>

<p style="margin-top: 2em;">But usually we just need to call it less:</p>
<code>std::unordered_map&lt;int, std::vector&lt;char>> map;
...
for (const auto elem : map) { ... }</code>
</section>

<section class="slide">
<h2>Banal Example</h2>
<p>The profiler shows that most time<br/>is spent executing <b>memcpy</b>.</p>
<p>Need to optimize this function?</p>

<p style="margin-top: 2em;">But usually we just need to call it less:</p>
<code>std::unordered_map&lt;int, std::vector&lt;char>> map;
...
for (const auto <b style="color: red;">&amp;</b> elem : map) { ... }</code>
</section>


<section class="slide">
<h2>What Metric to Measure?</h2>
<p>Number of cycles or CPU time;<br/>
&mdash; <b>rdtsc</b>/<b>rdtscp</b>, OS information (<b>getrusage</b>)</p>
<p>Number of instructions processed;<br/>
&mdash; CPU counters (through kernel &mdash; <b>perf_event_open</b><br/>&emsp; or directly &mdash; <b>rdpmc</b>)<br/>
&mdash; run in emulator (<b>valgrind</b>)</p>
<p>Number of bytes read from disk (or from file system?):<br/>
&mdash; application counters or OS information.</p>
<p>Real time between events (or its approximation?);<br/>
&mdash; timers in application;<br/>
&mdash; sampling;<br/>
...
</section>


<section class="slide">
<h2>Another Example</h2>
<p>Using CPU profiler.<br/>We optimized memcpy function, but the program didn't speed up.<br/>Because our program is bottlenecked by:</p>
<p>&mdash; disk reads;</p>
<p>&mdash; receiving data over network;</p>
<p>&mdash; waiting on mutex;</p>
<p>&mdash; sleep;</p>
</section>


<section class="slide">
<h2>Profiling Methods</h2>
<p><b>Instrumentation:</b></p>
<p>&mdash; add code to the program<br/>that measures its work;</p>
<p><b>Sampling:</b></p>
<p>&mdash; at random moments in time, look<br/>where code execution is;</p>
</section>


<section class="slide">
<h2>External or Internal?</h2>
<p><b>Internal profiler:</b><br/>
&mdash; application contains profiler code inside itself;<br/>
(1) explicitly in source code;<br/>
(2) without changing source code:<br/>
profiler added during compilation (<b>gprof (-pg)</b>, <b>LLVM XRay</b>)<br/> or during linking (<b>Google CPU profiler</b>);</p>
<p><b>External profiler:</b><br/>
&mdash; application requires no changes;<br/>
&mdash; external program or OS kernel monitors it<br/>(<b>poor man's profiler</b>, <b>Linux Perf</b>);</p>
</section>

<section class="slide">
<h2>How Much Does It Impact Performance?</h2>
<p>Running application under emulation.<br/>
Example: <b>valgrind</b>, slowdown of 50x and more.</p>
<p>Adding instructions to every function.<br/>
Example: <b>gprof</b>, slowdown of tens of times.</p>
<p>Adding <b>nop</b> instructions to large functions and on-the-fly patching.<br/>
Example: <b>LLVM XRay</b>, negligible impact if not used.</p>
<p>Sampling.<br/>
Example: <b>Linux Perf</b>, can be enabled in production.</p>
<p>Collecting ready metrics.<br/>
Example: <b>rdpmc</b>, almost free.</p>
</section>

<section class="slide">
<h2>Is Everything Already Written?</h2>
<p class="cloud">
<span>gprof</span> <span>valgrind</span> <span>linux perf</span><br/>
<span>oprofile</span> <span>Coz</span> <span>VTune</span> <span>Google CPU profiler</span><br/>
<span>Poor Man's profiler</span> <span>Pin</span> <span>LIKWID</span><br/>
<span>DTrace</span> <span>SystemTap</span></p>
</section>


<section class="slide">
<h2>What Do We Want?</h2>
<p>Keep the profiler constantly enabled in production:<br/>
&mdash; need near-zero performance impact;</p>

<p>Be able to associate profiles with specific queries:<br/>
&mdash; isolate <b>specific queries</b> on a loaded server<br/> and view their profiles;</p>

<p>Store profiling data in ClickHouse:<br/>
&mdash; aggregate profiles by query types,<br/> by users, across cluster;</p>

<p style="color: green;">Maybe a sampling profiler will work for us?</p>
</section>


<section class="slide">
<h2>Sampling Profilers</h2>
<p>At certain intervals, check where<br/>code execution was in all threads. Example: <b>Poor Man's Profiler</b>:</p>

<code style="font-size: 16pt;">#!/bin/bash
for x in $(seq 1 $nsamples)
  do
    <b style="color: green;">gdb</b> -ex "set pagination 0" \
      -ex "<b style="color: green;">thread apply all bt</b>" -batch -p $pid
    sleep $sleeptime
  done | \
 awk '
  BEGIN { s = ""; }
  /^Thread/ { print s; s = ""; }
  /^\#/ { if (s != "" ) { s = s "," $4} else { s = $4 } }
  END { print s }' | \
sort | uniq -c | sort -r -n -k 1,1</code>
</section>

<section class="slide">
<h2>Sampling Profilers</h2>
<p>At certain intervals, check where<br/>code execution was in all threads. Example: <b>Google CPU Profiler</b>:</p>

<p>Set a timer in each thread,<br/>which will send a <b>signal</b>* to that thread.<br/>For example, 100 times per second.</p>
<p>In the signal handler, capture the stack trace.</p>
<p>Aggregate stack traces.</p>
<p style="color: green; margin-top: 2em;">Looks trivial!</p>
<p style="font-size: 10pt;">* alternative &mdash; use <b>ptrace</b> from auxiliary process.</p>
</section>

<section class="slide">
<h2>The Task</h2>
<p>Develop a <b>sampling profiler</b> in ClickHouse, where<br/>collected information will be <b>tied to queries</b>.</p>
<p>Easy, because each thread in ClickHouse executes one query at a time, and we know which one.</p>
<p style="color: green; margin-top: 2em;">Looks trivial!</p>
</section>


<section class="slide">
<h2>The Task</h2>
<p>I didn't do this task :)</p>
<p>All development &mdash; <b>Nikita Lapkov</b>;<br/>&mdash; Yandex banner system developer;<br/>&mdash; Facebook developer;<br/>&mdash; ClickHouse contributor;<br/>&mdash; strong professional;<br/>&mdash; and generally a good person.</p>
</section>


<section class="slide">
<img style="height: 576px; float: right; margin-top: -20px; margin-right: -100px;" src="pictures/laplab.jpg" />
<p style="margin-top: 170px;">When we started the task,<br/>it turned out to be<br/>non-trivial.</p>
<p>Very non-trivial.</p>
</section>


    <section class="slide">
        <img src="pictures/adventure.jpg" style="width: 100%; margin-top: 50px;" />
        <p style="font-size: 8pt; color: #888; text-align: right;">&laquo;Rick and Morty&raquo;, ep. &laquo;Rest and Ricklaxation&raquo;, Justin Roiland and Dan Harmon, 2017</p>
    </section>


<section class="slide">
<h2>Problems</h2>
<p>How to do something in a signal handler?</p>
<p>In a signal handler, you can only call <b>signal-safe</b> functions.</p>
<p>Can't lock mutex*, wait on condvar, allocate memory...</p>
<p>Can write to file descriptor.</p>
<p><span style="color: green;">Can pass information to a separate thread via pipe</span>,<br/>and in that thread do everything else: log, insert into table.</p>
<p style="font-size: 10pt;">* question: can you use spinlock in a signal handler?</p>
</section>


<section class="slide">
<h2>How to Collect Stack Traces?</h2>
<p>1. Frame pointer chain walking.</p>
<p>Doesn't work if code is compiled with -f<b>omit-frame-pointer</b>.<br/>This is default when building with optimizations.</p>
<p>Can build code with -f<b>no-omit-frame-pointer</b>. But that's worse;<br/> <b>glibc</b> library is already built with -f<b>omit-frame-pointer</b>.</p>
<p style="font-size: 10pt; margin-top: 50px;">Question: ASan, MSan, TSan use exactly this method. Why does it work?</p>
</section>

<section class="slide">
<h2>How to Collect Stack Traces?</h2>
<p>2. <b>backtrace</b> function from execinfo.h &mdash; part of <b>libgcc</b>.</p>
<p>Internally does <b style="color: red;">dlopen</b>, locks <b style="color: red;">mutex</b>,<br/>then calls internal unwind implementation from libgcc.<br/>
<p>Not suitable for calling from signal handler.</p>
</section>

<section class="slide">
<h2>How to Collect Stack Traces?</h2>
<p>3. Using <b>libunwind</b>.</p>
<p>Should work, because see <b>asynchronous-unwind-tables</b>.</p>
<p>There are at least three variants of using libunwind:<br/>
&mdash; libunwind from libgcc*;<br/>
&mdash; libunwind "nongnu";<br/>
&mdash; LLVM libunwind;</p>
<p>And all three variants allocate memory and lock mutex.<br/><b style="color: red;">Not suitable for calling from signal handler.</b></p>
<p style="font-size: 10pt">* a C++ program with exception support already uses part of libunwind internally. Another libunwind implementation can be connected either separately &mdash; without symbol name conflicts, or as a complete replacement for exception handling implementation.</p>
</section>

<section class="slide">
<h2>How to Collect Stack Traces?</h2>
<p>4. Collect stack trace not from signal handler.</p>
<p>In signal handler pass <b>ucontext</b> to another thread via <b>pipe</b>.</p>
<p>But to convert ucontext to stack trace,<br/>the thread must be frozen.<br/>
&mdash; in signal handler have to wait &mdash; very slow;<br/>
&mdash; indirect locking &mdash; <b style="color: red;">unacceptable</b>.</p>
</section>

<section class="slide">
<h2>How to Collect Stack Traces?</h2>
<img style="float: left; height: 60%; margin-left: -60px; margin-top: -60px; margin-right: 50px;" src="pictures/optimal.webp"/>
<p>Chose the option &mdash; patch libunwind.</p>
</section>

<section class="slide">
<h2>What's Wrong with libunwind?</h2>
<p>1. nongnu libunwind doesn't pass tests under address sanitizer.</p>
<p>Decided to just switch to LLVM libunwind.</p>

<p style="color: green;">Bonus: also use LLVM libunwind instead of libgcc for C++ exception handling.</p>
<p>Though such build configuration is very inconvenient<br/>to describe in CMake.</p>

<code style="font-size: 10pt;">-Wl,--start-group
    .../libglibc-compatibility.a
    .../libcxx.a .../libcxxabi.a
    .../<b style="color: green;">libunwind.a</b>
-Wl,--end-group
-nodefaultlibs .../libclang_rt.builtins-x86_64.a
-lc -lm -lrt -lpthread -ldl</code>
</section>

<section class="slide">
<h2>What's Wrong with libunwind?</h2>
<p>2. libunwind allocates memory using <b>malloc</b>.</p>
<p>Possible solution: always allocate memory using <b>mmap</b><br/>&mdash; very slow.</p>
<p>Solution: buffer on stack and stack allocator on top of it.</p>
<p><a href="https://github.com/ClickHouse-Extras/libunwind/commit/500aa227911bd185a94bfc071d68f4d3b03cb3b1">https://github.com/ClickHouse-Extras/libunwind/commit/500aa227</a><br/>
<a href="https://github.com/ClickHouse-Extras/libunwind/commit/ec86b1c6a2c6b8ba316f429db9a6d- 4122dd12710">https://github.com/ClickHouse-Extras/libunwind/commit/ec86b1c6</a></p>
</section>

<section class="slide">
<h2>What's Wrong with libunwind?</h2>
<p>3. Missing register.</p>
<p><a href="https://github.com/ClickHouse-Extras/libunwind/commit/17a48fbfa7913ee889960a698516bd3ba51d63ee">https://github.com/ClickHouse-Extras/libunwind/commit/17a48fbf</a></p>
<p><a href="https://reviews.llvm.org/D66685">https://reviews.llvm.org/D66685</a></p>
</section>

<section class="slide">
<h2>What's Wrong with libunwind?</h2>
<p>4. Incorrect CFA.</p>
<code>unsigned char mincore_res = 0;
if (0 != syscall(SYS_mincore,
    (void*)(<b>cfa</b> / 4096 * 4096), 1, &amp;mincore_res))
{
    return UNW_EBADFRAME;
}
</code>
<p style="margin-top: 1em;"><a href="https://github.com/ClickHouse-Extras/libunwind/commit/36df74d804e03bf5fa4bdd2bfafde8662ad28129">https://github.com/ClickHouse-Extras/libunwind/commit/36df74d8</a></p>
</section>

<section class="slide">
<h2>What's Wrong with libunwind?</h2>
<p>5. FDE Cache.</p>
<p>Uses <b>rwlock</b>.</p>
<p>FDE Cache modification &mdash; for JIT code registration.<br/>Actually only read lock is used.</p>
<p>Even read lock &mdash; not signal safe and leads to <b style="color: red;">deadlock</b>.</p>
<p>Solution &mdash; <span style="color: green;">remove FDE Cache</span>.</p>
<p><a href="https://github.com/ClickHouse-Extras/libunwind/commit/96f5f17125a3d8eed890e365868ccaa96bcd2301">https://github.com/ClickHouse-Extras/libunwind/commit/96f5f171</a></p>
</section>

<section class="slide">
<h2>What's Wrong with libunwind?</h2>
<p>6. Using <b>dl_iterate_phdr</b> function.</p>
<p>Solution: lock-free PHDR Cache.</p>
<p>&mdash; doesn't work with thread sanitizer;<br/>
&mdash; need to update manually on dlopen;</p>
<p><a href="https://github.com/libunwind/libunwind/issues/16">https://github.com/libunwind/libunwind/issues/16</a><br/>
<a href="https://github.com/ClickHouse/ClickHouse/pull/6124">https://github.com/ClickHouse/ClickHouse/pull/6124</a></p>
<p style="font-size: 10pt;">Solution designed by Fedor Korotkiy, YT developer.</p>
</section>

<section class="slide">
<h2>What's Wrong with the Profiler?</h2>
<p>7. Profiler incompatibility with sanitizers.</p>
<p>Reason: sanitizers also use stack unwinding.</p>
<p>For this they use frame pointer and modify the <b>%rbp</b> register.</p>
<p>At this moment libunwind doesn't work.</p>
<p>Solution: don't use profiler under sanitizers.</p>
<p><a href="https://github.com/ClickHouse/ClickHouse/pull/6769">https://github.com/ClickHouse/ClickHouse/pull/6769</a></p>
</section>

<section class="slide">
<h2>What's Wrong with the Profiler?</h2>
<p>8. No syscall restart after signals.</p>
<p style="font-family: Monospace;">man 7 signal</p>
<p><b>SA_RESTART</b> doesn't work for all syscalls*:</p>
<p>&mdash; reading and writing to socket with timeout.</p>
<p>&mdash; sleep, usleep, nanosleep, clock_nanosleep.</p>
<p style="font-size: 10pt; margin-top: 50px;">* in FreeBSD and Mac OS X everything is different.</p>
</section>

<section class="slide">
<h2>What's Wrong with the Profiler?</h2>
<p>9. Incorrect syscall restart after signals:</p>
<p>&mdash; reading and writing to socket with timeout;</p>
<p>&mdash; restart the call, but don't update timeout;</p>
<p>Solution &mdash; always do poll before reading.</p>
<p><a href="https://github.com/ClickHouse/ClickHouse/pull/6386">https://github.com/ClickHouse/ClickHouse/pull/6386</a></p>
</section>

<section class="slide">
<h2>What's Wrong with the Profiler?</h2>
<p>10. Pipe overflow.</p>
<p>Solution:<br/>
&mdash; increase pipe size to 1 MB;<br/>
&mdash; if can't write to pipe &mdash; ignore.</p>
<p>Alternative solution:<br/>lock-free circular buffer instead of pipe.</p>
</section>

<section class="slide">
<h2>What's Wrong with the Profiler?</h2>
<p>11. Too frequent signals.</p>
<p>Solution: if <b>si_overrun</b> > 0 &mdash; skip processing.</p>
</section>

<section class="slide">
<h2>Result</h2>
</section>

<section class="slide">
<h2 style="font-size: 32pt;">Result</h2>
<p>1. Enable one or both settings:</p>
<code>SET query_profiler_<b>cpu</b>_time_period_ns = 1000000;</code>
<code style="margin-top: 10px;">SET query_profiler_<b>real</b>_time_period_ns = 1000000;</code>
<p style="margin-top: 1em;">2. Run queries.<br/>Data is written to <b>system.trace_log</b> table.</p>
<code style="margin-top: 1em; font-size: 12pt;">event_date:    2019-09-05
event_time:    2019-09-05 05:47:44
revision:      54425
timer_type:    CPU
thread_number: 149
query_id:      b1d8e7f9-48d8-4cb3-a768-0a6683f6f061
trace:         [140171472847748,61781958,110943821,117594728,117595220,115654933,
120321783,63251928,111161800,120329436,120331356,120308294,120313436,120319113,
120143313,115666412,120146905,111013972,118237176,111013972,117990912,111013972,
110986070,110986938,61896391,61897898,61887509,156206624,140171472807643]
</code>
</section>

<section class="slide">
<h2 style="font-size: 32pt;">Result</h2>
<p style="margin-top: -1em;"><b>trace</b> &mdash; array of addresses (stack trace);</p>
<p>Convert address to function name:<br/>&mdash; demangle(addressToSymbol(trace[1]))<br/>
Convert address to file name and line number:<br/>&mdash; addressToLine(trace[1])</p>
<p>* don't forget to install clickhouse-common-static-<b>dbg</b> package</p>
<p>Example: top functions</p>
<code style="margin-right: -10px;">SELECT count(),
  demangle(addressToSymbol(trace[1] AS addr)) AS symbol
FROM system.trace_log
WHERE event_date = today()
GROUP BY symbol
ORDER BY count() DESC LIMIT 10</code>
</section>

<section class="slide">
<h2 style="font-size: 32pt;">Result</h2>
<p>Example: top functions:</p>
<code style="margin-left: -100px; margin-right: -100px;">┌─count()─┬─symbol──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│     517 │ void LZ4::(anonymous namespace)::decompressImpl&lt;32ul, false>(char const*, char*, unsigned long)                                                                                                                         │
│     480 │ void DB::deserializeBinarySSE2&lt;4>(DB::PODArray&lt;unsigned char, 4096ul, Allocator&lt;false, false>, 15ul, 16ul>&amp;, DB::PODArray&lt;unsigned long, 4096ul, Allocator&lt;false, false>, 15ul, 16ul>&amp;, DB::ReadBuffer&amp;, unsigned long) │
│     457 │ DB::VolnitskyBase&lt;true, true, DB::StringSearcher&lt;true, true> >::search(unsigned char const*, unsigned long) const                                                                                                       │
│     270 │ read                                                                                                                                                                                                                    │
│     163 │ void LZ4::(anonymous namespace)::decompressImpl&lt;16ul, true>(char const*, char*, unsigned long)                                                                                                                          │
│     130 │ void LZ4::(anonymous namespace)::decompressImpl&lt;16ul, false>(char const*, char*, unsigned long)                                                                                                                         │
│      58 │ CityHash_v1_0_2::CityHash128WithSeed(char const*, unsigned long, std::pair&lt;unsigned long, unsigned long>)                                                                                                               │
│      44 │ void DB::deserializeBinarySSE2&lt;2>(DB::PODArray&lt;unsigned char, 4096ul, Allocator&lt;false, false>, 15ul, 16ul>&amp;, DB::PODArray&lt;unsigned long, 4096ul, Allocator&lt;false, false>, 15ul, 16ul>&amp;, DB::ReadBuffer&amp;, unsigned long) │
│      37 │ void LZ4::(anonymous namespace)::decompressImpl&lt;8ul, true>(char const*, char*, unsigned long)                                                                                                                           │
│      32 │ memcpy                                                                                                                                                                                                                  │
└─────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘</code>
</section>

<section class="slide">
<h2 style="font-size: 32pt;">Result</h2>
<p>Example: top contexts for a query:</p>
<code style="margin-right: -10px;">SELECT count(),
  arrayStringConcat(arrayMap(x -> concat(
    demangle(addressToSymbol(x)),
    '\n    ',
    addressToLine(x)), trace), '\n') AS sym
FROM system.trace_log
WHERE query_id = '1a1272b5-695a-4b17-966d-a1701b61b3eb'
  AND event_date = today()
GROUP BY trace
ORDER BY count() DESC
LIMIT 10</code>
</section>

<section class="slide">
<code style="margin-left: -100px; margin-right: -100px; font-size: 11pt;">count(): 154
sym:     DB::VolnitskyBase&lt;true, true, DB::StringSearcher&lt;true, true> >::search(unsigned char const*, unsigned long) const
    /opt/milovidov/ClickHouse/build_gcc9/dbms/programs/clickhouse
DB::MatchImpl&lt;true, false>::vector_constant(DB::PODArray&lt;unsigned char, 4096ul, Allocator&lt;false, false>, 15ul, 16ul> const&amp;, DB::PODArray&lt;unsigned long, 4096ul, Allocator&lt;false, false>, 15ul, 16ul> const&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char>, std::allocator&lt;char> > const&amp;, DB::PODArray&lt;unsigned char, 4096ul, Allocator&lt;false, false>, 15ul, 16ul>&amp;)
    /opt/milovidov/ClickHouse/build_gcc9/dbms/programs/clickhouse
DB::FunctionsStringSearch&lt;DB::MatchImpl&lt;true, false>, DB::NameLike>::executeImpl(DB::Block&amp;, std::vector&lt;unsigned long, std::allocator&lt;unsigned long> > const&amp;, unsigned long, unsigned long)
    /opt/milovidov/ClickHouse/build_gcc9/dbms/programs/clickhouse
DB::PreparedFunctionImpl::execute(DB::Block&amp;, std::vector&lt;unsigned long, std::allocator&lt;unsigned long> > const&amp;, unsigned long, unsigned long, bool)
    /home/milovidov/ClickHouse/build_gcc9/../dbms/src/Functions/IFunction.cpp:464
DB::ExpressionAction::execute(DB::Block&amp;, bool) const
    /usr/local/include/c++/9.1.0/bits/stl_vector.h:677
DB::ExpressionActions::execute(DB::Block&amp;, bool) const
    /home/milovidov/ClickHouse/build_gcc9/../dbms/src/Interpreters/ExpressionActions.cpp:759
DB::FilterBlockInputStream::readImpl()
    /home/milovidov/ClickHouse/build_gcc9/../dbms/src/DataStreams/FilterBlockInputStream.cpp:84
DB::IBlockInputStream::read()
    /usr/local/include/c++/9.1.0/bits/stl_vector.h:108
DB::ExpressionBlockInputStream::readImpl()
    /home/milovidov/ClickHouse/build_gcc9/../dbms/src/DataStreams/ExpressionBlockInputStream.cpp:34
DB::IBlockInputStream::read()
    /usr/local/include/c++/9.1.0/bits/stl_vector.h:108
DB::ParallelInputsProcessor&lt;DB::ParallelAggregatingBlockInputStream::Handler>::thread(std::shared_ptr&lt;DB::ThreadGroupStatus>, unsigned long)
    /usr/local/include/c++/9.1.0/bits/atomic_base.h:419
ThreadFromGlobalPool::ThreadFromGlobalPool&lt;void (DB::ParallelInputsProcessor&lt;DB::ParallelAggregatingBlockInputStream::Handler>::*)(std::shared_ptr&lt;DB::ThreadGroupStatus>, unsigned long), DB::ParallelInputsProcessor&lt;DB::ParallelAggregatingBlockInputStream::Handler>*, std::shared_ptr&lt;DB::ThreadGroupStatus>, unsigned long&amp;>(void (DB::ParallelInputsProcessor&lt;DB::ParallelAggregatingBlockInputStream::Handler>::*&amp;&amp;)(std::shared_ptr&lt;DB::ThreadGroupStatus>, unsigned long), DB::ParallelInputsProcessor&lt;DB::ParallelAggregatingBlockInputStream::Handler>*&amp;&amp;, std::shared_ptr&lt;DB::ThreadGroupStatus>&amp;&amp;, unsigned long&amp;)::{lambda()#1}::operator()() const
    /usr/local/include/c++/9.1.0/bits/shared_ptr_base.h:729
ThreadPoolImpl&lt;std::thread>::worker(std::_List_iterator&lt;std::thread>)
    /usr/local/include/c++/9.1.0/bits/atomic_base.h:551
execute_native_thread_routine
    /home/milovidov/ClickHouse/ci/workspace/gcc/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/unique_ptr.h:81
start_thread
    /lib/x86_64-linux-gnu/libpthread-2.27.so
clone
    /build/glibc-OTsEL5/glibc-2.27/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:97
</code>
</section>


<section class="slide">
<p><a href="https://github.com/Slach/clickhouse-flamegraph">https://github.com/Slach/clickhouse-flamegraph</a></p>
<img style="width: 100%; margin-top: 5%;" src="pictures/flamegraph_clickhouse.svg" />
</section>




<section class="slide">
<p>&nbsp;</p>
<p>ClickHouse Performance Optimization Secrets: <br/><a href="https://youtu.be/ltg8vstuHUU">https://youtu.be/ltg8vstuHUU</a></p>
<p>Query Performance Analysis in ClickHouse: <br/><a href="https://youtu.be/ondHe_JUyW4">https://youtu.be/ondHe_JUyW4</a></p>
<p>How Hash Tables Work in ClickHouse: <br/><a href="https://youtu.be/EoX82TEz2sQ">https://youtu.be/EoX82TEz2sQ</a></p>
<p>Parallel and Distributed GROUP BY: <br/><a href="https://youtu.be/SrucFOs8Y6c">https://youtu.be/SrucFOs8Y6c</a></p>
<p>How to Speed Up LZ4 Decompression: <br/><a href="https://youtu.be/V2CqQBICt7M">https://youtu.be/V2CqQBICt7M</a></p>
<p>Database Obfuscation: <br/><a href="https://youtu.be/2iR7i4akL44">https://youtu.be/2iR7i4akL44</a></p>
</section>

    <section class="slide">
        <h2>.</h2>
        <p>Web site: <a href="https://clickhouse.com/">https://clickhouse.com/</a></p>
        <p>Maillist: clickhouse-feedback@yandex-team.com</p>
        <p>YouTube: <a href="https://www.youtube.com/c/ClickHouseDB">https://www.youtube.com/c/ClickHouseDB</a></p>
        <p>Telegram chat: <a href="https://telegram.me/clickhouse_ru">https://telegram.me/clickhouse_ru</a>, <a href="https://telegram.me/clickhouse_en">clickhouse_en</a></p>
        <p>GitHub: <a href="https://github.com/ClickHouse/ClickHouse/">https://github.com/ClickHouse/ClickHouse/</a></p>
        <p>Twitter: <a href="https://twitter.com/ClickHouseDB">https://twitter.com/ClickHouseDB</a></p>
        <p>Google groups: <a href="https://groups.google.com/forum/#!forum/clickhouse">https://groups.google.com/forum/#!forum/clickhouse</a></p>
    </section>

    <div class="progress"></div>
    <script src="shower/shower.min.js"></script>

    <!--Video plugin-->
    <link rel="stylesheet" href="shower/shower-video.css">
    <script src="shower/shower-video.js"></script>
    <!--/Video plugin-->
</body>
</html>
