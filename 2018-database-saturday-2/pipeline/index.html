<!DOCTYPE HTML>


<html lang="en">
<head>
    <title>ClickHouse Query Execution Pipeline</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta property="og:image" content="pictures/cover.jpg">
    <meta property="og:title" content="ClickHouse Query Execution Pipeline">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="pictures/cover.jpg">
    <link rel="stylesheet" href="themes/yandex2/styles/screen-16x9.css">
    <style>
/* custom styles can be written here!! */
</style>
</head>
<body class="shower list">
    <header class="caption">
        <h1>ClickHouse Query Execution Pipeline</h1>
        <p>Nikolay Kochetov, Yandex</p>

    </header>



<!-- slide #1 -->
<section class="slide cover"><div><h2><img src="themes/yandex2/images/logo-ru.svg" alt="" class="logo" /></h2>

</div></section>

<!-- slide #2 -->
<section class="slide title" id="clickhouse-query-execution-pipeline"><div><h2>ClickHouse Query Execution Pipeline</h2>

<h3 id="-1"><img src="themes/yandex2/images/title-logo-ru.svg" alt="" /></h3>

<div class="authors">

<p>Nikolay Kochetov</p>
<p>ClickHouse Developer</p>




</div>

</div></section>

<!-- slide #3 -->
<section class="slide section" id="why-is-pipeline-needed-in-dbms"><div><h2>Why Is Pipeline Needed <br /> in a DBMS</h2>

</div></section>

<!-- slide #4 -->
<section class="slide" id="chain-of-independent-computations"><div><h2>Chain of Independent Computations</h2>

<p class="image-right"><img src="pictures/pipeline_simple_1.svg" alt="" /></p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="k">avg</span><span class="p">(</span><span class="k">length</span><span class="p">(</span><span class="n">URL</span><span class="p">))</span> <span class="k">FROM</span> <span class="n">hits</span> <span class="k">WHERE</span> <span class="n">URL</span> <span class="o">!=</span> <span class="s1">''</span></code></pre></figure>

<ul>
  <li>Reading <code class="highlighter-rouge">URL</code> column</li>
  <li>Computing <code class="highlighter-rouge">URL != ''</code></li>
  <li>Filtering</li>
  <li>Computing <code class="highlighter-rouge">length(URL)</code></li>
  <li>Aggregation</li>
</ul>

<p><strong>Each operation can be executed independently</strong></p>

</div></section>

<!-- slide #5 -->
<section class="slide" id="pipeline-execution-tasks"><div><h2>Pipeline Execution Tasks</h2>
<p><strong>What benefits does using a computational pipeline provide?</strong></p>
<ul>
  <li>Abstraction of computations from operation execution order</li>
  <li>Parallelization of computations</li>
  <li>Balancing computational resources (CPU, GPU, FPGA)</li>
</ul>

</div></section>

<!-- slide #6 -->
<section class="slide" id="volcano-an-extensible-and-parallel-query-evaluation-system"><div><h2>Volcano — An Extensible and Parallel Query Evaluation System</h2>

<p>Pipeline represented as a graph of operators (Exchange operator)</p>

<p><strong>Each operator (of relational algebra) supports the interface:</strong></p>
<ul>
  <li>open() - prepare for execution</li>
  <li>next() - return next row (or EOF)</li>
  <li>close() - finish execution</li>
</ul>

<p><strong>Row-by-row query execution (tuple-at-time)</strong></p>

</div></section>

<!-- slide #7 -->
<section class="slide" id="volcano"><div><h2>Volcano</h2>

<p><strong>Advantages</strong></p>
<ul>
  <li>Simple interface</li>
  <li>Old proven method</li>
  <li>Supports multitasking</li>
</ul>

<p><strong>Disadvantages</strong></p>
<ul>
  <li>Many instructions per row</li>
  <li>Low IPC (Instructions Per Cycle) value</li>
  <li>No support for vector operations</li>
</ul>

</div></section>

<!-- slide #8 -->
<section class="slide" id="column-computations"><div><h2>Column Computations</h2>

<p>MonetDB/X100: Hyper-Pipelining Query Execution</p>

<p><strong>Idea</strong></p>
<ul>
  <li>All computations are performed on column chunks (size 1024)</li>
  <li>Developed MIL language for writing operations on columns</li>
  <li>Fast vectorized X100 engine</li>
</ul>

</div></section>

<!-- slide #9 -->
<section class="slide" id="column-computations-1"><div><h2>Column Computations</h2>
<p><strong>Result:</strong></p>
<ul>
  <li>Reduced number of operations per row</li>
  <li>Increased IPC through vector operations</li>
  <li>Queries became memory-bound instead of CPU-bound</li>
</ul>

<p><strong>Disadvantages</strong></p>
<ul>
  <li>Increased memory consumption</li>
</ul>

</div></section>

<!-- slide #10 -->
<section class="slide section" id="how-query-pipeline-is-executed"><div><h2>How Query Pipeline Is Executed</h2>

</div></section>

<!-- slide #11 -->
<section class="slide" id="query-pipeline-execution"><div><h2>Query Pipeline Execution</h2>

<p><strong>Pipeline can be executed differently</strong></p>
<ul>
  <li>push: "forward" execution order. Push data into the beginning.</li>
  <li>pull: "backward" execution order. Pull data from the end.</li>
  <li>arbitrary order within topological sort constraints</li>
</ul>

<p><br /></p>

<p><img src="pictures/pull_push.svg" alt="" /></p>

</div></section>

<!-- slide #12 -->
<section class="slide" id="query-pipeline-execution-1"><div><h2>Query Pipeline Execution</h2>

<p><strong>Let's consider the task in a generalized form</strong></p>
<ul>
  <li>Operation knows how to execute itself</li>
  <li>Only need to be able to get the next pipeline operation</li>
  <li>Represent pipeline as a data structure that needs to be traversed</li>
</ul>

<p><strong>Data structure iteration</strong></p>
<ul>
  <li>Selecting next element</li>
  <li>Operation on data</li>
</ul>

</div></section>

<!-- slide #13 -->
<section class="slide" id="types-of-data-iteration"><div><h2>Types of Data Iteration</h2>
<p><strong>External</strong></p>
<ul>
  <li>Selecting next element is described externally</li>
  <li>Example: for loop, iterators</li>
  <li>Control over iteration order and termination moment</li>
</ul>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">:</span> <span class="n">array</span><span class="p">)</span>  <span class="c1">/// Outer iteration.
</span><span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">element</span><span class="p">)</span>  <span class="c1">/// Early exit.
</span>        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

</div></section>

<!-- slide #14 -->
<section class="slide" id="types-of-data-iteration-1"><div><h2>Types of Data Iteration</h2>
<p><strong>Internal</strong></p>
<ul>
  <li>Selecting next element is determined by data structure</li>
  <li>Cannot choose order or terminate iteration early</li>
  <li>Has call stack, code is simplified</li>
</ul>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="n">Tree</span><span class="o">::</span><span class="n">inOrder</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">function</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left_child</span><span class="p">)</span>
        <span class="n">left_child</span><span class="o">-&gt;</span><span class="n">inOrder</span><span class="p">(</span><span class="n">function</span><span class="p">);</span>

    <span class="n">function</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">right_child</span><span class="p">)</span>
        <span class="n">right_child</span><span class="o">-&gt;</span><span class="n">inOrder</span><span class="p">(</span><span class="n">function</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

</div></section>

<!-- slide #15 -->
<section class="slide" id="query-pipeline-execution-2"><div><h2>Query Pipeline Execution</h2>
<p><strong>push and pull approaches are implemented with internal iteration</strong></p>
<ul>
  <li>difficult to achieve vertical parallelization</li>
  <li>special handling of premature query termination</li>
  <li>execution flow tied to data flow (since stack is used)</li>
</ul>

<p><strong>Graph representation allows external iteration</strong></p>

<p>Example: LocustDB</p>
<ul>
  <li>All data stored in memory</li>
  <li>Query execution in topological sort order</li>
  <li>Each operation processes a chunk of data</li>
</ul>

</div></section>

<!-- slide #16 -->
<section class="slide" id="pipeline-execution-in-clickhouse"><div><h2>Pipeline Execution in ClickHouse</h2>

<p>Mixed scheme</p>
<ul>
  <li>IBlockInputStream - data read stream (pull)</li>
  <li>IBlockOutputStream - data write stream (push)</li>
  <li>BlockIO - stream connection point</li>
</ul>

<p>Query execution - transferring from InputStream to OutputStream</p>

<p><strong>Some block operations are the same for InputStream and OutputStream</strong></p>

</div></section>

<!-- slide #17 -->
<section class="slide section" id="how-to-parallelize-query-execution"><div><h2>How to Parallelize Query Execution</h2>

</div></section>

<!-- slide #18 -->
<section class="slide" id="parallel-query-execution"><div><h2>Parallel Query Execution</h2>

<p><strong>Approaches:</strong></p>
<ul>
  <li>by operations (intra-operator): execute slow operations <br /> (IO, sort, group by) in multiple threads</li>
  <li>by data (bushy): copy pipeline per thread</li>
  <li>by pipeline parts (vertical): different parts in different threads</li>
</ul>

</div></section>

<!-- slide #19 -->
<section class="slide" id="vertical-pipeline-parallelization"><div><h2>Vertical Pipeline Parallelization</h2>

<p class="image-right"><img src="pictures/pipeline_async.svg" alt="" /></p>

<p><strong>Volcano: exchange operator</strong></p>
<ul>
  <li>open() - create new process</li>
  <li>next() - RPC call</li>
</ul>

<p><strong>ClickHouse: AsynchronousBlockInputStream</strong></p>
<ul>
  <li>Creates new thread</li>
  <li>Increases query latency</li>
  <li>Used in "special cases"</li>
</ul>

</div></section>

<!-- slide #20 -->
<section class="slide" id="parallel-execution-in-clickhouse"><div><h2>Parallel Execution in ClickHouse</h2>

<p><strong>Data parallelism</strong></p>
<ul>
  <li>Data sources return multiple streams for reading</li>
  <li>Pipeline is built simultaneously for all streams</li>
  <li>Streams are merged into one in some operations (order by, group by)</li>
</ul>

<p><strong>Example</strong></p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="k">length</span><span class="p">(</span><span class="n">URL</span><span class="p">)</span> <span class="k">AS</span> <span class="n">l</span><span class="p">,</span> <span class="k">count</span><span class="p">()</span> <span class="k">FROM</span> <span class="n">hits</span> <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">l</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">l</span></code></pre></figure>

<p><img src="pictures/pipeline_full_1.svg" alt="" /></p>

</div></section>

<!-- slide #21 -->
<section class="slide" id="parallel-execution-in-clickhouse-1"><div><h2>Parallel Execution in ClickHouse</h2>
<p>Let's look at query execution result</p>

<p><img src="pictures/dense_1.png" alt="" /></p>

<p><strong>URL length distribution has a heavy tail</strong></p>

</div></section>

<!-- slide #22 -->
<section class="slide" id="parallel-execution-in-clickhouse-2"><div><h2>Parallel Execution in ClickHouse</h2>
<p><strong>Data is processed at different speeds</strong></p>

<p><img src="pictures/time_chart_half.png" alt="" /></p>

</div></section>

<!-- slide #23 -->
<section class="slide" id="parallel-execution-in-clickhouse-3"><div><h2>Parallel Execution in ClickHouse</h2>
<p><strong>Solution - "stealing" tasks from neighboring thread during reading</strong></p>

<p><img src="pictures/time_chart.png" alt="" /></p>

</div></section>

<!-- slide #24 -->
<section class="slide" id="parallel-execution-in-clickhouse-4"><div><h2>Parallel Execution in ClickHouse</h2>
<p><strong>Task stealing doesn't solve all problems</strong></p>
<ul>
  <li>Still can't parallelize vertically</li>
  <li>Arbitrary data reading order</li>
</ul>

<p><strong>Example: reading in primary key order (optimization)</strong></p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">value</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">LIMIT</span> <span class="mi">10</span>                 <span class="c1">-- Any 10 rows</span>
<span class="k">SELECT</span> <span class="n">value</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">value</span> <span class="k">LIMIT</span> <span class="mi">10</span>  <span class="c1">-- All data</span></code></pre></figure>

<p>What if data is already partially sorted (within a part)?</p>
<ul>
  <li>Can optimize if reading correctly</li>
  <li><b>Cannot steal tasks</b></li>
</ul>

</div></section>

<!-- slide #25 -->
<section class="slide section" id="how-pipeline-execution-will-change-in-clickhouse"><div><h2>How Pipeline Execution Will Change in ClickHouse</h2>

</div></section>

<!-- slide #26 -->
<section class="slide" id="processors-in-clickhouse"><div><h2>Processors in ClickHouse</h2>
<p><strong>Representing query processing pipeline as a graph</strong></p>

<p>Components:</p>
<ul>
  <li>Processor (processsor): arbitrary operation on a block</li>
  <li>Port (port): input or output for processor (stores data block)</li>
  <li>Ports (input and output) can be connected with connect() function</li>
</ul>

<p><img src="pictures/processors_items.svg" alt="" /></p>

</div></section>

<!-- slide #27 -->
<section class="slide" id="processors-in-clickhouse-1"><div><h2>Processors in ClickHouse</h2>

<p>Types of processors</p>
<ul>
  <li>source, sink - files, tables, table functions, …</li>
  <li>simple operation (function call, filtering, adding column)</li>
  <li>resize - arbitrary change in number of data streams</li>
</ul>

<p><br />
<img src="pictures/merge/merge_0.svg" alt="" /></p>

</div></section>

<!-- slide #28 -->
<section class="slide" id="pipeline-execution"><div><h2>Pipeline Execution</h2>

<p><strong>Processors are in different states</strong></p>
<ul>
  <li>NeedData, PortFull, Unneeded - need to transfer data</li>
  <li>Ready, Finished - can continue/finish work</li>
  <li>Async, Wait - asynchronous execution</li>
</ul>

<p><strong>Pipeline execution - also a processor</strong></p>
<ul>
  <li>Single-threaded execution - in topological traversal order</li>
  <li>Multi-threaded - graph traversal in multiple threads using heuristics</li>
</ul>

</div></section>

<!-- slide #29 -->
<section class="slide" id="pipeline-execution-1"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_1.svg" alt="" /></p>

</div></section>

<!-- slide #30 -->
<section class="slide" id="pipeline-execution-2"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_2.svg" alt="" /></p>

</div></section>

<!-- slide #31 -->
<section class="slide" id="pipeline-execution-3"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_3.svg" alt="" /></p>

</div></section>

<!-- slide #32 -->
<section class="slide" id="pipeline-execution-4"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_4.svg" alt="" /></p>

</div></section>

<!-- slide #33 -->
<section class="slide" id="pipeline-execution-5"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_5.svg" alt="" /></p>

</div></section>

<!-- slide #34 -->
<section class="slide" id="pipeline-execution-6"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_6.svg" alt="" /></p>

</div></section>

<!-- slide #35 -->
<section class="slide" id="pipeline-execution-7"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_7.svg" alt="" /></p>

</div></section>

<!-- slide #36 -->
<section class="slide" id="pipeline-execution-8"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_8.svg" alt="" /></p>

</div></section>

<!-- slide #37 -->
<section class="slide" id="pipeline-execution-9"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_9.svg" alt="" /></p>

</div></section>

<!-- slide #38 -->
<section class="slide" id="pipeline-execution-10"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_10.svg" alt="" /></p>

</div></section>

<!-- slide #39 -->
<section class="slide" id="pipeline-execution-11"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_11.svg" alt="" /></p>

</div></section>

<!-- slide #40 -->
<section class="slide" id="pipeline-execution-12"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_12.svg" alt="" /></p>

</div></section>

<!-- slide #41 -->
<section class="slide" id="pipeline-execution-13"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_13.svg" alt="" /></p>

</div></section>

<!-- slide #42 -->
<section class="slide" id="pipeline-execution-14"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_14.svg" alt="" /></p>

</div></section>

<!-- slide #43 -->
<section class="slide" id="pipeline-execution-15"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_15.svg" alt="" /></p>

</div></section>

<!-- slide #44 -->
<section class="slide" id="pipeline-execution-16"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_16.svg" alt="" /></p>

</div></section>

<!-- slide #45 -->
<section class="slide" id="pipeline-execution-17"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge_17.svg" alt="" /></p>

</div></section>

<!-- slide #46 -->
<section class="slide" id="pipeline-execution-18"><div><h2>Pipeline Execution</h2>

<p><strong>Processors</strong></p>
<ul>
  <li>White - needs input data</li>
  <li>Yellow - ready for execution</li>
  <li>Red - output port is full</li>
</ul>

<p><strong>Ports</strong></p>
<ul>
  <li>White - free, yellow - occupied</li>
</ul>

<p><img src="pictures/merge/merge.gif" alt="" /></p>

</div></section>

<!-- slide #47 -->
<section class="slide" id="shared-pipeline-execution"><div><h2>Shared Pipeline Execution</h2>

<p>Example from QueryLog</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="k">sum</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="k">sum</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="k">sum</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span></code></pre></figure>

<p><strong>Can compose shared pipeline for multiple queries</strong></p>

<p><img src="pictures/many_q.svg" alt="" /></p>

</div></section>

<!-- slide #48 -->
<section class="slide" id="pipeline-optimizations"><div><h2>Pipeline Optimizations</h2>
<p><strong>Query optimizations can be performed at pipeline construction stage</strong></p>
<ul>
  <li>Based on data flows and their properties (<i>reliable, corresponds to essence</i>)</li>
  <li>Alternative to AST optimizations (<i>laborious, error-prone</i>)</li>
</ul>

<p><strong>Examples:</strong></p>
<ul>
  <li>Information about column monotonicity</li>
  <li>Statistics: number of rows, number of distinct values, distribution</li>
  <li>Merging pipeline parts with the same result</li>
</ul>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">value</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">x</span> <span class="k">FROM</span> <span class="k">table</span><span class="p">)</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">x</span> <span class="k">FROM</span> <span class="k">table</span><span class="p">)</span></code></pre></figure>

</div></section>

<!-- slide #49 -->
<section class="slide" id="resource-allocation"><div><h2>Resource Allocation</h2>

<p><strong>Unified pipeline allows transparent CPU sharing between users</strong></p>
<ul>
  <li>Processor is created for individual user (possibly multiple)</li>
  <li>Block processing by processor — user's resource consumption</li>
  <li>Can limit resources only under high load</li>
  <li>Choice of operation execution priority</li>
</ul>

</div></section>

<!-- slide #50 -->
<section class="slide" id="pipeline-description-language"><div><h2>Pipeline Description Language</h2>

<p><strong>Idea: create language for describing query execution pipeline</strong></p>
<ul>
  <li>Describes nodes and their connections</li>
  <li>Allows pipeline (de)serialization</li>
</ul>

<p><strong>Additional capabilities</strong></p>
<ul>
  <li>Transfer ready pipelines to shards: savings on query analysis</li>
  <li>Low-level interface</li>
  <li>Pipelines not describable through SQL syntax</li>
</ul>

</div></section>

<!-- slide #51 -->
<section class="slide" id="introspection"><div><h2>Introspection</h2>

<p><strong>External</strong></p>
<ul>
  <li>Query plan as tree (already implemented)</li>
  <li>Step-by-step optimization results</li>
</ul>

<p><strong>Internal</strong></p>
<ul>
  <li>Debug processors with statistics and logs</li>
  <li>Information about creation process</li>
  <li>More understandable call stack</li>
</ul>

</div></section>

<!-- slide #52 -->
<section class="slide" id="what-we-expect-from-new-pipeline"><div><h2>What We Expect from New Pipeline</h2>
<ul>
  <li>Vertical parallelization</li>
  <li>Introspection (EXPLAIN, global plan) of query</li>
  <li>Cheap query cancellation</li>
  <li>Serialization (description language) of pipeline</li>
  <li>Data statistics (ORDER BY optimization on PK)</li>
  <li>Resource sharing and user priorities</li>
  <li>Processing multiple queries simultaneously</li>
  <li>Reducing number of threads</li>
  <li>Simplifying shuffle distributed join implementation</li>
</ul>

</div></section>

<!-- slide #53 -->
<section class="slide contacts" id="contacts"><div><h2>Contacts</h2>

<ul>
  <li class="site">Web site: <a href="https://clickhouse.com/">https://clickhouse.com</a></li>
  <li class="site">Google groups: <a href="https://groups.google.com/forum/#!forum/clickhouse">https://groups.google.com/forum/#!forum/clickhouse</a></li>
  <li class="telegram">Telegram (Ru): <a href="https://telegram.me/clickhouse_ru">https://telegram.me/clickhouse_ru</a> (over 1900 members)</li>
  <li class="telegram">Telegram (En): <a href="https://telegram.me/clickhouse_en">https://telegram.me/clickhouse_en</a></li>
  <li class="github">Github: <a href="https://github.com/ClickHouse/ClickHouse/">https://github.com/ClickHouse/ClickHouse</a></li>
  <li class="twitter">Twitter: <a href="https://twitter.com/ClickHouseDB">https://twitter.com/ClickHouseDB</a></li>
  <li class="mail">Maillist: <a href="mailto:clickhouse-feedback@yandex-team.com">clickhouse-feedback@yandex-team.com</a></li>
</ul>

</div></section>



    <footer class="badge"><a href="https://github.yandex-team.ru/presentation/jekyller">Fork me on Github</a></footer>

    <script src="shower.min.js"></script>
    <!-- Copyright © 2018 Nikolay Kochetov, Yandex -->
</body>
</html>
