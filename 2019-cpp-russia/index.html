<!DOCTYPE html>
<html lang="en">
<head>
    <title>Not-So-Dumb Pointers in ClickHouse</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:image" content="pictures/preview.jpg">
    <meta property="og:title" content="Not-So-Dumb Pointers in ClickHouse">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="pictures/preview.jpg">
    <link rel="stylesheet" href="shower/themes/clickhouse/styles/styles.css">

    <style>
        code { display: block; white-space: pre; background-color: #EEE; }
        pre { line-height: 1; }
    </style>
</head>
<body class="shower list">
    <header class="caption">
        <h1>Not-So-Dumb Pointers in ClickHouse</h1>
    </header>

    <section class="slide" id="cover">
        <h1 style="margin-top: 200px;"><span style="background: rgba(255, 255, 255, 0.75)">Not-So-Dumb Pointers<br/>in ClickHouse</span></h1>
    </section>

<section class="slide">
<h2>The Foundation of ClickHouse is Columns</h2>

<p>On disk &mdash; columns.<br/>
Data is stored by columns.</p>

<p>In RAM &mdash; columns.<br/>
Data is processed by columns.</p>
</section>


<section class="slide">
<h2>How Columns are Stored in RAM</h2>

<p>As chunks of columns &mdash; for example, 65,536 elements.</p>
<p>Chunk size &mdash; depends on many things.</p>
<p>For SELECT &mdash; see the max_block_size setting.</p>
</section>


<section class="slide">
<h2>How Columns are Stored in RAM</h2>
<p>Represented as objects with the IColumn interface.</p>
<p>Variants &mdash; ColumnVector&lt;T&gt;, ColumnString, ColumnArray...</p>

<p>ColumnVector&lt;T&gt; &mdash; almost like std::vector&lt;T&gt;.<br/>
But under the IColumn interface.<br/>
And instead of std::vector&lt;T&gt; &mdash; PODArray&lt;T&gt; (why?).</p>
</section>


<section class="slide">
<h2>How Columns are Stored in RAM</h2>
<img style="float: left; height: 60%; margin-left: -60px; margin-top: -60px; margin-right: 20px;" src="pictures/optimal.webp"/>
<p>Previously it was std::vector. PODArray &mdash; is just an optimization.</p>

<p>PODArray:<br/>
&mdash; no extra memset;<br/>
&mdash; has 15 bytes padding at the end;<br/>
&mdash; uses an allocator interface different from std::allocator, which sometimes allows mremap.</p>
</section>


<section class="slide">
<h2>How Columns are Stored in RAM</h2>

<p>ColumnString &mdash; consists of two components:</p>

<p>1. Bytes laid out sequentially.<br/>
2. Offsets to the i+1 string.</p>

<code>h e l l o \0 w o r l d \0
6 12</code>
</section>


<section class="slide">
<h2>How Columns are Stored in RAM</h2>

<p>ColumnConst</p>

<p>Made of one nested column,<br/>
containing one value.</p>
</section>


<section class="slide">
<h2>What the IColumn Interface Provides</h2>

<p>Basic operations:<br/>
&mdash; cut &mdash; extract part of a column, for LIMIT implementation;<br/>
&mdash; filter &mdash; for WHERE implementation;<br/>
&mdash; compareAt, permute &mdash; for ORDER BY implementation;<br/>
...</p>
</section>


<section class="slide">
<h2>Almost All Operations are Immutable</h2>

<p>virtual <b>Ptr</b> filter(const Filter &amp; filt, ssize_t result_size_hint) <b>const</b> = 0;</p>

<p>Instead of modifying contents, they create<br/>and return a new column object.</p>

<p>This is normal, since operations are "coarse-grained".</p>

<p>But there are also "fine-grained", mutating operations.</p>
</section>


<section class="slide">
<h2>IColumn, what it's responsible for:</h2>

<p>&mdash; storing data in RAM;<br/>
&mdash; common operations on columns.</p>

<h2>IColumn, what it's similar to:</h2>

<p>&mdash; Apache Arrow;<br/>
&mdash; arrays in NumPy;<br/>
&mdash; arrays in APL, J, K.</p>
</section>


<section class="slide">
<h2>Motivation</h2>

<p>Isolate maximally efficient<br/>inner loops from wrapper code.</p>
<p>Code doesn't have to be efficient as a whole.</p>
<p>Optimizable places should be localizable.</p>

<p><b>&laquo;vectorized engine&raquo;</b></p>

<p>Bonus:<br/>
&mdash; SIMD instructions;<br/>
&mdash; clever optimizations for homogeneous data<br/>
(IColumn::filter, LIKE function implementation);</p>
</section>


<section class="slide">
<h2>Common Subexpression Elimination</h2>

<p><span style="white-space: pre; font-family: Monospace, Courier New; background-color: #FED; padding: 10px;">SELECT f(x + y), g(x + y)</span></p>
<p>&mdash; <span style="white-space: pre; font-family: Monospace, Courier New; background-color: #FED; padding: 10px;">x + y</span> &mdash; is the same expression appearing multiple times.</p>
<p><span style="white-space: pre; font-family: Monospace, Courier New; background-color: #FED; padding: 10px;">SELECT x + y AS a, x + y AS b</span></p>
<p>&mdash; <b>a</b> and <b>b</b> &mdash; are actually the same columns.</p>

<p>Simple, elegant and incorrect solution:<br/>&mdash; use <b>shared_ptr&lt;IColumn></b>.</p>
<p>Columns <b>a</b> and <b>b</b> would just reference the same thing.</p>
</section>


<section class="slide">
<h2>Common Subexpression Elimination</h2>

<p><span style="white-space: pre; font-family: Monospace, Courier New">SELECT f(x + y), g(x + y)</span></p>
<p>The query AST can also be glued &mdash; turned from a tree into a DAG:</p>
<pre>
  x   y   x   y              x   y
<span style="color: gray;">   ↘ ↙     ↘ ↙                ↘ ↙</span>
    +       +                  +
<span style="color: gray;">    ↓       ↓      &minus;&minus;&minus;>       ↙ ↘</span>
    f       g                f   g
<span style="color: gray;">     ↘     ↙                 ↓   ↓</span>
      SELECT                 SELECT
</pre>
<p>Use <b>shared_ptr&lt;IAST></b> for nodes and share identical nodes.</p>
</section>


<section class="slide">
<h2 style="font-size: 32pt;">All Function Computations are Immutable</h2>

<p>Computations:<br/><div style="white-space: pre; font-family: Monospace, Courier New; background-color: #FED; padding: 10px; line-height: 1.25">c1 = x;<br/>c2 = y;<br/>c3 = plus(c1, c2);<br/>c4 = f(c3);<br/>c5 = g(c3);</div></p>
<p>&mdash; can be executed independently,<br/>in arbitrary order of graph traversal<br/>and in parallel.</p>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">Problems with Using shared_ptr</h2>

<p>Some operations are <b>mutable</b>.</p>
<p>For example:
<br/>&mdash; <span style="white-space: pre; font-family: Monospace, Courier New; background-color: #FED; padding: 0 10px 0 10px;">IColumn::insert</span> &mdash; insert one value at the end of the column;
<br/>&mdash; <span style="white-space: pre; font-family: Monospace, Courier New; background-color: #FED; padding: 0 10px 0 10px;">IColumn::insertRangeFrom</span> &mdash; insert a chunk of another column at the end.</p>
<p>Usage example:</p>
<p><span style="white-space: pre; font-family: Monospace, Courier New; background-color: #FED; padding: 10px;">INSERT INTO table SELECT a, b FROM other</span></p>
<p>&mdash; gluing small blocks into larger ones during INSERT;
<br/>&mdash; but <b>mutable</b> operations cannot be applied to <b>shared</b> data.</p>
<p>Persistent data structures?</p>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">Problems with Using shared_ptr</h2>

<p>If the AST is glued into a DAG with shared_ptr,<br/>then rewriting one piece of the query changes another.</p>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">Obvious Solution</h2>

<p>Use <b>shared_ptr&lt;const T></b> for shared data<br/>
and <b>unique_ptr&lt;T></b> when data needs to be modified.</p>

<p>Example:</p>

<code><span style="color: blue;">// Create object and modify it.</span>
std::unique_ptr&lt;T> u{std::make_unique&lt;T>()};
u->modify();

<span style="color: blue;">// When object is ready, it can be shared.</span>
std::shared_ptr&lt;const T> s1{std::move(u)};
std::shared_ptr&lt;const T> s2 = s1;

<span style="color: blue;">// Nobody can modify the shared object.</span></code>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">Obvious Solution</h2>

<p style="margin-top: -1em;">If we need to modify a shared object?
<br/>&mdash; just clone it:</p>

<code><span style="color: blue;">// Create object and modify it.</span>
std::unique_ptr&lt;T> u{std::make_unique&lt;T>()};
u->modify();

<span style="color: blue;">// When object is ready, it can be shared.</span>
std::shared_ptr&lt;const T> s1{u.release()};
std::shared_ptr&lt;const T> s2 = s1;

<span style="color: blue;">// Nobody can modify the shared object.</span>
<span style="color: blue;">// But can clone it, then modify the new copy.</span>
std::unique_ptr&lt;T> u2{s2->clone()};
u2->modify();
</code>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">Obvious Solution</h2>

<p>Gluing small blocks into larger ones.</p>
<p>Was:</p>
<code>result->insertRangeFrom(*source, 0, length);</code>
<p style="margin-top: 1em;">Became:</p>
<code>result_mutable = result->clone();
result_mutable->insertRangeFrom(*source, 0, length);
result = result_mutable;</code>
<p style="margin-top: 1em;"><span style="color: red;">Extra copying, even if refcount == 1.</span>
<br/>In case of many iterations, all copies except the first<br/>will be guaranteed to be redundant.</p>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">Obvious Solution</h2>
<img style="float: right; height: 60%; margin-right: -60px; margin-top: -100px; margin-left: 20px;" src="pictures/not_optimal.webp"/>
<p style="margin-top: 1em;"><span style="color: red;">Extra copying, even if refcount == 1.</span>
</p><p>In case of many iterations, all copies<br/>except the first will be guaranteed to be redundant.</p>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">&nbsp;</h2>

<p>Can we clone an object only if refcount &gt; 1 and otherwise<br/><span style="color: green;">magically</span> convert <b>shared_ptr</b> to <b>unique_ptr</b>?</p>

<p>No, because they have different <span style="color: red;">memory layout</span> and everything else.</p>
<p>sizeof(unique_ptr&lt;T>) == sizeof(void*)<br/>
sizeof(shared_ptr&lt;T>) == 2 * sizeof(void*)</p>
<p>(in libc++ or libstdc++ implementation)</p>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">Copy-on-write?</h2>

<p>The <b>copy-on-write</b> technique is notoriously known<br/>from old implementations of <b>std::string</b>.</p>
<p>Example: libstdc++ with old C++ ABI by default in gcc before 5.1.</p>
<p>CoW-strings are <span style="color: red;">slow</span>.</p>
<p><a href="https://www.youtube.com/watch?v=rJWSSWYL83U">https://www.youtube.com/watch?v=rJWSSWYL83U</a></p>
</section>

<section class="slide">
<h2 style="font-size: 36pt;">Copy-on-write?</h2>

<p>Why CoW-strings &mdash; are not very good:</p>
<p>&mdash; CoW implementation requires refcount tracking, which requires atomic operations in multithreaded programs;</p>
<p>&mdash; but in typical cases, most strings are <span style="color: red;">small</span> and copying them (with SSO or a good allocator) is cheaper than changing refcnt;</p>
<p>&mdash; copying on modification is done <span style="color: red;">implicitly</span>, which requires extremely complex code;</p>
<p>&mdash; especially for proper support of non-const iterator<br/>and non-const operator[];</p>
<p>&mdash; starting with C++11, move replaces copying of temporary objects;</p>
</section>

<section class="slide">
<h2 style="font-size: 36pt;">Copy-on-write?</h2>

<p>CoW <span style="color: red;">should NOT</span> be used:</p>
<p>1. For small objects that are easy to copy.</p>
<p>&mdash; <span style="color: green;">but if object is heavy, it's better to share it<br/>and increase refcount instead of copying</span>.
</p><p>Example: <b>fbstring</b> uses CoW for long strings and SSO for small ones.</p>
<p>2. If copying is performed implicitly.</p>
<p>&mdash; <span style="color: green;">but you can make one method that gives access
<br/>to the non-const part of the interface (prepare object for modification)<br/> clone if refcount > 1 or "reinterpret_cast" otherwise</span>.</p>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">Reasonable CoW</h2>

<code style="margin-top: -1em; font-size: 16pt;"><span style="color: blue;">// Creating and assigning to immutable ptr.</span>
COW&lt;T>::Ptr x = COW&lt;T>::create(1);
<span style="color: blue;">// Sharing single immutable object in two ptrs.</span>
COW&lt;T>::Ptr y = x;
<span style="color: blue;">// Now x and y are shared.</span>

<span style="color: blue;">// Change value of x.</span>
{
    <span style="color: blue;">// Creating mutable ptr.
    // It can clone an object under the hood if it was shared.</span>
    COW&lt;T>::MutablePtr mutate_x = std::move(*x).mutate();
    <span style="color: blue;">// Using non-const methods of an object.</span>
    mutate_x->set(2);
    <span style="color: blue;">// Assigning pointer 'x' to mutated object.</span>
    x = std::move(mutate_x);
}
<span style="color: blue;">// Now x and y are unshared and have different values.</span>
</code>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">Reasonable CoW</h2>

<p><b>COW&lt;T>::Ptr</b> &mdash; behaves similarly to <b>std::shared_ptr&lt;const T></b></p>
<p><b>COW&lt;T>::MutablePtr</b> &mdash; behaves similarly to <b>std::unique_ptr&lt;T></b></p>

<p>Converting mutable to immutable:</p>
<code>COW&lt;T>::MutablePtr x;
COW&lt;T>::Ptr y = std::move(x);
</code>

<p style="margin-top: 1em;">Converting immutable to mutable:</p>
<code>COW&lt;T>::Ptr x;
COW&lt;T>::MutablePtr y = std::move(*x).mutate();
</code>
<p style="margin-top: 1em;">&mdash; performs copying if refcount > 1.</p>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">Reasonable CoW</h2>

<p><span style="white-space: pre; font-family: Monospace, Courier New; background-color: #FED; padding: 10px;">std::move(*x).mutate();</span></p>
<p>or</p>
<p><span style="white-space: pre; font-family: Monospace, Courier New; background-color: #FED; padding: 10px;">std::move(x)->mutate();</span></p>
<p>?</p>
<p>1. In C++ there's no rvalue qualified <span style="white-space: pre; font-family: Monospace, Courier New;">operator-></span>
<br/><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3723.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3723.html</a></p>
<p>2. We want to invalidate the value itself, not the Ptr.<br/>
(we can still use the assignment operator on Ptr)<br/>
Update after the talk: actually there are no problems with calling<br/>the assignment operator after move.</p>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">Implementation</h2>

<code>template &lt;typename Derived>
class COW : public
    boost::intrusive_ref_counter&lt;Derived>
</code>

<p style="margin-top: 1em;">&mdash; we'll use an intrusive pointer<br/>&mdash; add refcount to the object.</p>

<code>class IColumn : public COW&lt;IColumn>
{
private:
    friend class COW&lt;IColumn>;
    virtual MutablePtr clone() const = 0;
</code>

<p style="margin-top: 1em;">&mdash; <b>COW&lt;T>::mutate</b> method will call <b>T::clone</b> if needed.</p>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">Implementation</h2>

<code style="font-size: 16pt; margin-top: -1em;">template &lt;typename Derived>
class COW : public <b style="color: #08F;">boost::intrusive_ref_counter</b>&lt;Derived>
{
    template &lt;typename T>
    class <b style="color: #0BF;">IntrusivePtr</b> : public <b style="color: blue;">boost::intrusive_ptr</b>&lt;T> {...}

protected:
    template &lt;typename T>
    class <b style="color: #A50;">mutable_ptr</b> : public <b style="color: #0BF;">IntrusivePtr</b>&lt;T> {...}

public: using <b style="color: #F80;">MutablePtr</b> = <b style="color: #A50;">mutable_ptr</b>&lt;Derived>;

protected:
    template &lt;typename T>
    class <b style="color: green;">immutable_ptr</b> : public <b style="color: #0CF;">IntrusivePtr</b>&lt;const T> {...}

public: using <b style="color: #0B0;">Ptr</b> = <b style="color: green;">immutable_ptr</b>&lt;Derived>;
}
</code>
</section>


<section class="slide">
<code style="font-size: 14pt;">template &lt;typename T>
class mutable_ptr : public IntrusivePtr&lt;T>
{
...
public:
    <span style="color: blue;">/// Copy: not possible.</span>
    mutable_ptr(const mutable_ptr &amp;) = delete;

    <span style="color: blue;">/// Move: ok.</span>
    mutable_ptr(mutable_ptr &amp;&amp;) = default;
    mutable_ptr &amp; operator=(mutable_ptr &amp;&amp;) = default;

    <span style="color: blue;">/// Initializing from temporary of compatible type.</span>
    template &lt;typename U>
    mutable_ptr(mutable_ptr&lt;U> &amp;&amp; other) : Base(std::move(other)) {}

    mutable_ptr() = default;
    mutable_ptr(std::nullptr_t) {}
};
</code>
</section>

<section class="slide">
<code style="font-size: 12pt;">template &lt;typename T>
class immutable_ptr : public IntrusivePtr&lt;const T>
{ ...
public:
    <span style="color: blue;">/// Copy from immutable ptr: ok.</span>
    immutable_ptr(const immutable_ptr &amp;) = default;
    immutable_ptr &amp; operator=(const immutable_ptr &amp;) = default;

    template &lt;typename U>
    immutable_ptr(const immutable_ptr&lt;U> &amp; other) : Base(other) {}

    <span style="color: blue;">/// Move: ok.</span>
    immutable_ptr(immutable_ptr &amp;&amp;) = default;
    immutable_ptr &amp; operator=(immutable_ptr &amp;&amp;) = default;

    <span style="color: blue;">/// Initializing from temporary of compatible type.</span>
    template &lt;typename U>
    immutable_ptr(immutable_ptr&lt;U> &amp;&amp; other) : Base(std::move(other)) {}

    <span style="color: blue;">/// Move from mutable ptr: ok.</span>
    template &lt;typename U>
    immutable_ptr(mutable_ptr&lt;U> &amp;&amp; other) : Base(std::move(other)) {}

    <span style="color: blue;">/// Copy from mutable ptr: not possible.</span>
    template &lt;typename U>
    immutable_ptr(const mutable_ptr&lt;U> &amp;) = delete;

    immutable_ptr() = default;
    immutable_ptr(std::nullptr_t) {}
};
</code>
</section>

<section class="slide">
<code style="font-size: 14pt;">class COW : public boost::intrusive_ref_counter&lt;Derived>
{
protected:
    MutablePtr shallowMutate() const
    {
        if (this->use_count() > 1)
            return derived()->clone();
        else
            return assumeMutable();
    }

public:
    MutablePtr <b>mutate</b>() const &amp;&amp; { return shallowMutate(); }

    MutablePtr assumeMutable() const
    {
        return const_cast&lt;COW*>(this)->getPtr();
    }

    Derived &amp; assumeMutableRef() const
    {
        return const_cast&lt;Derived &amp;>(*derived());
    }
</code>
</section>

<section class="slide">
<h2 style="font-size: 36pt;">Inheritance</h2>

<code style="font-size: 16pt;">template &lt;typename Base, typename Derived>
class COWHelper : public Base
</code>

<code style="font-size: 16pt; margin-top: 1em;">class IColumn
    : public COW&lt;IColumn>
{
    friend class COW&lt;IColumn>;
    virtual MutablePtr clone() const = 0;
    virtual ~IColumn() {}
};

class ConcreteColumn
    : public COWHelper&lt;IColumn, ConcreteColumn>
{
    friend class COWHelper&lt;IColumn, ConcreteColumn>;
};
</code>
</section>

<section class="slide">
<h2 style="font-size: 36pt;">Inheritance</h2>
<p style="margin-bottom: 2em;">Inheritance diagram:</p>

<pre style="line-height: 1.5;">boost::intrusive_ref_counter&lt;IColumn>
                <span style="color: gray">↑</span>
          COW&lt;IColumn>
                <span style="color: gray">↑</span>
             <b>IColumn</b>
                <span style="color: gray">↑</span>
   COWHelper&lt;IColumn, ConcreteColumn>
                <span style="color: gray">↑</span>
          <b>ConcreteColumn</b>
</pre>
</section>

<section class="slide">
<h2 style="font-size: 36pt;">Composition / Aggregation</h2>
<code style="font-size: 16pt;">class ColumnPair final
    : public COWHelper&lt;IColumn, ColumnPair>
{
private:
    <b>SomePtr a;</b>
    <b>SomePtr b;</b>
}
</code>
<p style="margin-top: 1em;">It's unclear whether to make class members MutablePtr or Ptr?</p>
</section>


<section class="slide">
<h2 style="font-size: 36pt;">Composition / Aggregation</h2>
<p>Approach 1: immutable members.</p>
<p>Object contains immutable members inside.<br/>
In all non-const methods, mutate is called,
<br/>modifications are made and assigned back.</p>
<p>Disadvantages:</p><p>
Extra checks and atomic operations<br/>on each call to non-const methods.</p>
</section>

<section class="slide">
<h2 style="font-size: 36pt;">Composition / Aggregation</h2>
<p>Approach 2: mutable members.</p>
<p>Object contains mutable members inside.<br/>
Two objects cannot have shared class members.</p>
<p>Disadvantages:</p><p>
Shared class members are needed.<br/>Example: columns with arrays having matching lengths.</p>
</section>

<section class="slide">
<h2 style="font-size: 36pt;">Composition / Aggregation</h2>
<p>Approach 3: immutable members and deep-mutation.</p>
<p>Object contains immutable members inside.<br/>
The mutate method performs deep mutation of all class members,
<br/>which guarantees their uniqueness in mutable objects.
<br/>In all non-const methods <b>assumeMutableRef</b> is used.</p>
<p>Disadvantages:</p><p>
Complex implementation.<br/>
The <b>assumeMutableRef</b> method is unsafe.</p>
</section>

<section class="slide">
<h2 style="font-size: 36pt;">Composition / Aggregation</h2>
<p style="font-size: 32pt;">std::experimental::propagate_const</p>
</section>

<section class="slide">
<h2 style="font-size: 36pt;">Composition / Aggregation</h2>
<p style="margin-top: -1em;">Approach 4: chameleon_ptr.</p>
<p>Object contains <b>chameleon</b> members inside.<br/>
Which behave as immutable if the object is const
<br/>and as mutable if the object is not const.</p>

<style>
.chameleon
{
    color: red;
    animation: anim 15s;
    -moz-animation: anim 15s infinite;
    -webkit-animation: anim 15s infinite;
}

@-moz-keyframes anim
{
    0%   {color: #F80;}
    50%  {color: green;}
    100% {color: #F80;}
}

@-webkit-keyframes anim
{
    0%   {color: #F80;}
    50%  {color: green;}
    100% {color: #F80;}
}
</style>

<code>template &lt;typename T>
class <b class="chameleon">chameleon_ptr</b>
{
private:
 immutable_ptr<T> value;
public:
 <span style="color: green;">const T &amp; operator*() const { return *value; }</span>
 <span style="color: #A50;">T &amp; operator*() { return value->assumeMutableRef(); }</span>
...
}
</code>
</section>

<section class="slide">
<h2 style="font-size: 36pt;">Type Polymorphism by const</h2>

<code>using T = X;
using const T = Y;
</code>

<p style="margin-top: 1em;">Where X and Y &mdash; are different types with the same memory layout.<br/>T works approximately like <span style="white-space: pre; font-family: Monospace, Courier New;">union { X x; Y y; }</span>.</p>

<code>template &lt;typename T>
using COWPtr&lt;T> = mutable_ptr&lt;T>;

template &lt;typename T>
using const COWPtr&lt;T> = immutable_ptr&lt;T>;
</code>
</section>

<section class="slide">
<h2 style="font-size: 36pt;">Type Polymorphism by const</h2>

<p>It's unlikely worth doing this in C++.</p><p>C++ is already too complex :)</p>
</section>


    <section class="slide">
        <p style="font-size: 32pt; margin-top: 1em;"><a href="https://github.com/ClickHouse/ClickHouse/blob/master/dbms/src/Common/COW.h">https://github.com/ClickHouse/ClickHouse/<br/>&nbsp;&nbsp;&nbsp;&nbsp;blob/master/dbms/src/Common/COW.h</a></p>
        <p>&mdash; 300 lines of code, 40% of which are comments.</p>
    </section>


    <section class="slide">
        <h2>.</h2>
    </section>

    <div class="progress"></div>
    <script src="shower/shower.js"></script>
<footer class="badge">
    <a href="https://presentations.clickhouse.com/">ClickHouse Theater</a>
</footer>
</body>
</html>
