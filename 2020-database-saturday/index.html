<!DOCTYPE html>
<html lang="en">
<head>
    <title>Backend Saturday</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:image" content="pictures/preview.jpg">
    <meta property="og:title" content="Backend Saturday">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="pictures/preview.jpg">
    <link rel="stylesheet" href="shower/themes/clickhouse/styles/styles.css">

    <style>
        code { display: block; white-space: pre; background-color: #EEE; }
    </style>
</head>
<body class="shower list">
    <header class="caption">
        <h1>Backend Saturday</h1>
    </header>
    <section class="slide" id="cover">
        <h1 style="margin-top: 150px; font-size: 32pt;"><div>Two Low-Level Optimizations</div><div style="text-align: right;">That I Made Yesterday</div></h1>
    </section>

    <section class="slide">
        <h2>Or:</h2>
<h2>&mdash; How I Stayed Home and Wrote Code.</h2>
    </section>


    <section class="slide">
        <h2>Optimizations in ClickHouse</h2>

<p><span style="color: green;">&plus;</span> Performance is the main product quality of ClickHouse.</p>
<p><span style="color: green;">&plus;</span> We constantly optimize everything...</p>
<p>&nbsp;</p>
<p><span style="color: red;">&minus;</span> Every optimization is a complex experiment.</p>
<p><span style="color: red;">&minus;</span> Sometimes the experiment fails already in production.</p>
    </section>


    <section class="slide">
        <h2>Examples of Controversial Optimizations</h2>

<p><img style="float: right; width: 35%; margin-right: -80px; margin-top: -100px; margin-left: 0px;" src="pictures/not_optimal.webp"/>Optimizations that people carefully made,<br/> but which later "backfired".</p>

<p>From the Linux kernel:</p>
<p>&mdash; NUMA awareness;</p>
<p>&mdash; Huge Pages.</p>

<p style="color: gray; font-size: 80%; margin-top: 2em;">From the developers' point of view:<br/>&mdash; these are good optimizations; users are to blame for all problems.</p>
    </section>


    <section class="slide">
        <h2>NUMA Awareness</h2>

<p>&mdash; the system has multiple processors;</p>
<p>&mdash; memory access speed is non-uniform;</p>
<p>&mdash; parts of memory belong to different processors;</p>
<p>&mdash; working with "your own" memory is faster.</p>
    </section>

    <section class="slide">
        <h2>NUMA</h2>
        <img src="pictures/numa.png" style="width: 100%;" />
        <p style="color: gray; font-size: 10pt;">2017, James E Chamings, <a href="https://software.intel.com/content/www/ru/ru/develop/articles/use-intel-quickassist-technology-efficiently-with-numa-awareness.html">https://software.intel.com/</a></p>
    </section>

    <section class="slide">
        <h2>NUMA Awareness</h2>

<p>How to allocate physical memory:</p>
<p>1. Any way.
<p>2. <span style="color: green;">In that part of memory that belongs to the processor<br/>&emsp; that is currently executing the code.</span></p>
    </section>


    <section class="slide">
        <h2>NUMA Awareness</h2>

<p style="color: green;">The Linux kernel was optimized.</p>
<p style="color: red;">MySQL in production started getting killed by OOM killer.</p>

<p style="font-size: 80%; margin-top: 2em;"><a href="https://blog.jcole.us/2010/09/28/mysql-swap-insanity-and-the-numa-architecture/">https://blog.jcole.us/2010/09/28/mysql-swap-insanity-and-the-numa-architecture/</a></p>
    </section>


    <section class="slide">
        <h2>Huge Pages</h2>

<p>&mdash; programs work with virtual memory;</p>
<p>&mdash; virtual memory is mapped to physical memory;</p>
<p>&mdash; using a page table (address translation table);</p>
<p>&mdash; the mapping unit is a memory <b>page</b>;</p>
<p>&mdash; on x86_64 the default page size is 4 KB;</p>
<p>&mdash; the page table itself is also stored in memory;</p>

    </section>


    <section class="slide">
        <h2>Huge Pages</h2>

<p>The page table is stored in memory;<br/>
&mdash; on x86_64 the default page size is 4 KB.</p>

<p>Example: a program uses 200 GiB of RAM;<br/>
&mdash; that's up to 50 million entries in the page table.</p>

<p>Page table data structure<br/>
&mdash; 5-level 512-way trie.</p>

<!--
https://en.wikipedia.org/wiki/Intel_5-level_paging

4096 - 12 bit
2 MB - 11 bit
Each level is 9 bit (512-way)
5 * 9 = 45
45 + 12 = 57
-->

<p>To read something from virtual memory,<br/>do we need to read from memory 5 more times?</p>
<p>&mdash; cached by CPU using TLB.</p>
    </section>

    <section class="slide">
        <img src="pictures/page_tables.svg" style="height: 90%;" />
        <p style="color: gray; font-size: 10pt;">Bellezzasolo - Own work, CC BY-SA 4.0, Wikipedia, 2018</p>
    </section>

    <section class="slide">
    <h2>TLB, Example</h2>
    <p>AMD Zen 2</p>
    <p>iTLB:<br/>
    &mdash; 64 entry L1, fully associative;<br/>
    &mdash; 512 entry L2, 8-way set associative.</p>
    <p>dTLB:<br/>
    &mdash; 64 entry L1, fully associative;<br/>
    &mdash; 2048 entry L2, 16-way set associative.</p>
    <p>Information from <a href="https://en.wikichip.org/wiki/amd/microarchitectures/zen_2">wikichip.org</a>.</p>
    </section>

    <section class="slide">
        <h2>Huge Pages</h2>

<p>Address translation is cached using TLB.</p>
<p>TLB size is small.<br/>TLB miss &mdash; memory read (hopefully from cache).</p>

<p style="color: red; margin-top: 2em;">Everything is slow?</p>
<p style="color: green; margin-bottom: 2em;">Solution &mdash; enable Huge Pages.</p>

<p>On x86_64 you can use pages<br/>of size 2 MB or 1 GB instead of 4 KB.</p>
    </section>


    <section class="slide">
        <h2>Huge Pages</h2>

<p>&mdash; explicitly allocated huge pages:<br/>
<pre style="margin-bottom: 0;"># echo 10 > /proc/sys/vm/nr_hugepages</pre>
also see hugetlbfs.
</p>

<p>&mdash; transparent huge pages:<br/>
<pre>$ cat /sys/kernel/mm/transparent_hugepage/enabled
always [madvise] never</pre>
</p>
    </section>

    <section class="slide">
        <h2>Huge Pages</h2>
<p>Examples from real life:</p>
<p>How my friends "sped up" MySQL.</p>
<p>How colleagues from a neighboring department sped up their entire production<br/>and everything stopped working.</p>
<p>How I sped up ClickHouse and everything started slowing down.</p>
<p style="margin-top: 2em; font-size: 80%;"><a href="https://github.com/ClickHouse/ClickHouse/commit/60054d177c8bc190e8187c7c5f5e8495a1957a04">https://github.com/ClickHouse/ClickHouse/commit/60054d177c8bc190e8187c7c5f5e8495a1957a04</a></p>
    </section>

    <section class="slide">
        <h2>Examples of Controversial Optimizations</h2>

<p>&mdash; NUMA awareness;</p>
<p>&mdash; Huge Pages.</p>

<p style="color: gray; font-size: 80%; margin-top: 2em;">From the developers' point of view:<br/>&mdash; these are good optimizations; users are to blame for all problems.</p>

<p>Just forget about these optimizations?</p>
    </section>


    <section class="slide">
        <h2 style="font-size: 32pt">Performance Tests in ClickHouse</h2>
    </section>

    <section class="slide">
        <h2 style="font-size: 32pt">Performance Tests in ClickHouse</h2>
        <img src="pictures/perf_check.png"/>
    </section>

    <section class="slide">
        <h2 style="font-size: 32pt">Performance Tests in ClickHouse</h2>
        <img style="margin-left: -50px; margin-top: -1em; height: 100%;" src="pictures/perf_results.png"/>
    </section>

    <section class="slide">
        <h2 style="font-size: 32pt">Performance Tests in ClickHouse</h2>
        <p>&mdash; executes queries alternating between two different server builds;</p>
        <p>&mdash; collects execution time statistics:<br/>
        &emsp; for example 10 runs on the old version and 10 on the new;</p>
        <p>&mdash; takes bootstrap distribution of the random variable:<br/>
        &emsp; what is the difference in query execution time<br/>
        &emsp; on a randomly selected pair of runs on old and new versions.</p>
        <p>&mdash; calculates the median of this random variable<br/>
        &emsp; and compares it with the 95% quantile of the random variable,
        <br/>&emsp; calculated when comparing the server with itself.</p>

        <p style="margin-top: 2em; font-size: 80%; color: gray;">Box, Hunter, Hunter "Statistics for Experimenters", p. 78: "A Randomized Design Used in the Comparison of Standard and Modified Fertilizer Mixtures for Tomato Plants."</p>
    </section>

    <section class="slide">
        <h2 style="font-size: 32pt">Performance Tests in ClickHouse</h2>
        <p>Outputs one of the results:</p>
        <p style="color: green;">&mdash; difference is insignificant;</p>
        <p style="color: green;">&mdash; query sped up;</p>
        <p style="color: red;">&mdash; query slowed down;</p>
        <p style="color: red;">&mdash; query is unstable.</p>

        <p>Sometimes instead of an unstable query<br/>false acceleration or slowdown is shown.</p>
        <p>Why can query execution time be unstable?</p>
    </section>

    <section class="slide">
        <h2 style="font-size: 32pt">Performance Tests in ClickHouse</h2>
        <p>Why can query execution time be unstable?</p>
        <p>Need to look at query execution metrics:</p>
        <p>&mdash; <b>userspace</b> metrics:<br/>query execution time, rows processed, opened files;</p>
        <p>&mdash; <b>OS kernel</b> metrics:<br/>wait time, iowait, blkio read bytes;</p>
        <p>&mdash; <b>CPU</b> metrics:<br/>instructions, branch mispredictions, L1d cache misses, dTLB misses;</p>
        <p style="color: green;">All these metrics exist in ClickHouse and are calculated for each query!</p>
    </section>

    <section class="slide">
        <h2 style="font-size: 32pt">Performance Tests in ClickHouse</h2>
        <img src="pictures/metrics_cdf.png" style="width: 95%; margin-top: -1em;"/>
    </section>

    <section class="slide">
        <h2 style="font-size: 32pt">Performance Tests in ClickHouse</h2>
        <img src="pictures/metrics_comparison.png" style="width: 100%; margin-top: -1em; margin-left: -1em;"/>
    </section>

    <section class="slide">
        <h2>The Problem</h2>
        <p>Pull request adding support<br/>for UInt256, Int256, Decimal256 types.</p>
        <p>Binary size increased (324 MB -> 429 MB).</p>
        <p>Perf tests show <span style="color: green;">no slowdowns</span>.</p>
        <p>But <span style="color: red;">the number of unstable queries increased!</span></p>
    </section>

    <section class="slide">
        <h2>The Problem</h2>
        <p>The number of unstable queries increased!</p>
        <p>By enumerating all metrics we found that:</p>
        <p>&mdash; the number of <b style="color: red;">iTLB misses</b> increased.</p>
    </section>

    <section class="slide">
        <h2>The Problem</h2>
        <p>The number of <b style="color: red;">iTLB misses</b> increased.</p>
        <p>It seems we need to put the code segment into Huge Pages :)</p>
        <p>How to do this?</p>
        <p>Use hugetlbfs? But in the test infrastructure<br/>we won't be able to allocate explicit huge pages.<br/>
        And we'll have to do linking in some strange way.</p>
        <p>Use transparent huge pages?<br/>
        But they only work for anonymous memory mappings.<br/>
        And our code is an mmap of the executable file segment.</p>
    </section>

    <section class="slide">
        <h2 style="font-size: 32pt">Crazy Solution</h2>
        <p>Need to remap machine code on the fly!</p>
        <p>&mdash; allocate new memory chunk for code (<b>mmap</b>);</p>
        <p>&mdash; do <b>madvise</b>(..., <b>MADV_HUGE</b>);</p>
        <p>&mdash; do <b>mprotect</b>, add executable and remove write access;</p>
        <p>&mdash; copy machine code there;</p>
        <p>&mdash; transfer control to it.</p>
    </section>

    <section class="slide">
        <h2 style="font-size: 32pt">Crazy Solution</h2>
        <p>Need to remap machine code on the fly!</p>
        <p>Doesn't work because we don't have <b>P</b>osition <b>I</b>ndependent <b>C</b>ode*.</p>

        <p style="color: gray; font-size: 80%; margin-top: 2em;">* because it's more optimal, +1% performance.</p>

        <p style="margin-top: 2em;">Need to delete the old code, allocate new memory at the old location<br/>and copy the machine code there.</p>
        <p style="color: green; font-size: 80%;">The worst code I've written in my life.</p>
    </section>


    <section class="slide">
        <h2 style="font-size: 30pt;">Crazy Solution</h2>
<p>Step 1: determine the address and length of the memory chunk with our code.</p>

<code style="font-size: 12pt; line-height: 1.25">std::pair&lt;void *, size_t> getMappedArea(void * ptr)
{
    uintptr_t uintptr = reinterpret_cast&lt;uintptr_t>(ptr);
    ReadBufferFromFile in("<b>/proc/self/maps</b>");

    while (!in.eof())
    {
        uintptr_t begin = readAddressHex(in);
        assertChar('-', in);
        uintptr_t end = readAddressHex(in);
        skipToNextLineOrEOF(in);

        if (begin &lt;= uintptr &amp;&amp; uintptr &lt; end)
            return {reinterpret_cast&lt;void *>(begin), end - begin};
    }

    throw Exception("Cannot find mapped area for pointer", ErrorCodes::LOGICAL_ERROR);
}</code>
    </section>

    <section class="slide">
        <h2 style="font-size: 30pt;">Crazy Solution</h2>
<p>Step 1: determine the address and length of the memory chunk with our code.</p>

<code style="font-size: 16pt; line-height: 1.25">void <b>remapExecutable</b>()
{
    auto [begin, size] = getMappedArea(
        reinterpret_cast&lt;void *>(<b>remapExecutable</b>));

    remapToHugeStep1(begin, size);
}
</code>
    </section>

    <section class="slide">
        <h2 style="font-size: 30pt;">Crazy Solution</h2>
<p>Step 1: determine the address and length of the memory chunk with our code.</p>

<code style="font-size: 16pt; line-height: 1.25">void <b>remapExecutable</b>()
{
    auto [begin, size] = getMappedArea(
        reinterpret_cast&lt;void *>(<b>+[]{}</b>)); <span style="color: red">
    // Don't write code like this.</span>

    remapToHugeStep1(begin, size);
}
</code>

    <p style="color: gray; font-size: 80%; margin-top: 2em;">* don't write like this.</p>
    </section>

    <section class="slide">
        <h2 style="font-size: 30pt;">Crazy Solution</h2>
<p style="margin-top: -1em;">Step 2: allocate temporary memory,<br/>copy code there and transfer control to it.</p>

<code style="font-size: 12pt; line-height: 1.25; margin-left: -3em; margin-right: -3em;">void remapToHugeStep1(void * begin, size_t size)
{
    <span style="color: green">/// Allocate scratch area and copy the code there.</span>
    void * scratch = mmap(nullptr, size,
        PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (MAP_FAILED == scratch)
        throwFromErrno(fmt::format("Cannot mmap {} bytes", size),
            ErrorCodes::CANNOT_ALLOCATE_MEMORY);

    memcpy(scratch, begin, size);

    <span style="color: green">/// Offset to the scratch area from previous location.</span>
    int64_t offset = reinterpret_cast&lt;intptr_t>(scratch) - reinterpret_cast&lt;intptr_t>(begin);

    <span style="color: green">/// Jump to the next function inside the scratch area.</span>
    reinterpret_cast&lt;void(*)(void*, size_t, void*)>(
        reinterpret_cast&lt;intptr_t>(<b>remapToHugeStep2</b>) + offset)(begin, size, scratch);
}</code>
    </section>

    <section class="slide">
        <h2 style="font-size: 30pt;">Crazy Solution</h2>
<p style="margin-top: -1em;">Step 3: delete old code and allocate new memory at its location.</p>

<code style="font-size: 14pt; line-height: 1.25;">void remapToHugeStep2(void * begin, size_t size, void * scratch)
{
    int munmap_res = munmap(begin, size);

    if (munmap_res == 0)
        std::cerr &lt;&lt; "Successfully unmapped\n";
    <span style="color: red">/// ^ segfault here :(</span>
</code>
    </section>

    <section class="slide">
        <h2 style="font-size: 30pt;">Crazy Solution</h2>
<p style="margin-top: -1em;">Step 3: delete old code and allocate new memory at its location.</p>

<p>After <b>munmap</b> of code, calling any function will cause segfault,<br/>
as functions in non-PIC code are called by absolute addresses*, which no longer exist.</p>

<p>But we need functions <b>mmap</b>, <b>madvise</b>, <b>mprotect</b>, <b>memcpy</b>!</p>

<p><b>mmap</b>, <b>madvise</b>, <b>mprotect</b> &mdash; wrappers around system calls;<br/>
<b>memcpy</b> &mdash; fully userspace function.</p>

<p style="color: gray; font-size: 80%; margin-top: 2em;">* functions from .so, like libc.so, are called a bit differently.</p>
    </section>

    <section class="slide">
        <h2 style="font-size: 30pt;">System Calls</h2>
<code>std::cerr &lt;&lt; "Hello, world\n";</code>
<p>&mdash; C++</p>
<code style="margin-top: 1em;">write(2, "Hello, world\n", 13);</code>
<p>&mdash; Libc, POSIX</p>
<code style="margin-top: 1em;">syscall(SYS_write, 2, "Hello, world\n", 13);</code>
<p>&mdash; Libc</p>
<code style="margin-top: 1em;">__asm__("movq %rdi, %rax;
         ...
         syscall")</code>
    </section>

    <section class="slide">
        <h2 style="font-size: 30pt;">System Calls</h2>
<code style="font-size: 16pt; line-height: 1.25;">__attribute__((__noinline__)) int64_t our_syscall(...)
{
    __asm__ __volatile__ (R"(
        movq %%rdi,%%rax;
        movq %%rsi,%%rdi;
        movq %%rdx,%%rsi;
        movq %%rcx,%%rdx;
        movq %%r8,%%r10;
        movq %%r9,%%r8;
        movq 8(%%rsp),%%r9;
        <b>syscall</b>;
        ret
    )" : : : "memory");
    return 0;
}</code>
    </section>

    <section class="slide">
        <h2 style="font-size: 30pt;">Memcpy</h2>

        <p>Just write a loop.</p>
        <p>But first set <b>-fno-tree-loop-distribute-patterns</b>.</p>
<code style="font-size: 16pt; line-height: 1.25;">while (src &lt; src_end)
{
    _mm_storeu_si128(dst, _mm_loadu_si128(src));

    ++dst;
    ++src;
}</code>
    <p style="margin-top: 1em;">Not very efficient, but OK.</p>
    <p><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56888">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56888</a></p>
    </section>


    <section class="slide">
        <h2 style="font-size: 30pt;">Crazy Solution</h2>
<p style="margin-top: -1em;">Step 3: delete old code and allocate new memory at its location.</p>

<code style="font-size: 12pt; line-height: 1.25;">int64_t (*syscall_func)(...) = reinterpret_cast&lt;int64_t (*)(...)>(
    reinterpret_cast&lt;intptr_t>(our_syscall) + offset);

int64_t munmap_res = syscall_func(<b>SYS_munmap</b>, begin, size);
if (munmap_res != 0)
    return;
<span style="color: green">/// Map new anonymous memory region in place of the old region with code.</span>
int64_t mmap_res = syscall_func(<b>SYS_mmap</b>, begin, size, ... <b>MAP_FIXED</b>, -1, 0);
if (-1 == mmap_res)
    syscall_func(<b>SYS_exit</b>, 1);
<span style="color: green">/// As the memory region is anonymous, we can do madvise with MADV_HUGEPAGE.</span>
syscall_func(<b>SYS_madvise</b>, begin, size, <b>MADV_HUGEPAGE</b>);
<span style="color: green">/// Copy the code from scratch area to the old memory location.</span>
...
<span style="color: green">/// Make the memory area with the code executable and non-writable.</span>
syscall_func(<b>SYS_mprotect</b>, begin, size, PROT_READ | PROT_EXEC);

void(* volatile step3)(void*, size_t, size_t) = <b>remapToHugeStep3</b>;
step3(scratch, size, offset);</code>
    </section>

    <section class="slide">
        <h2 style="font-size: 30pt;">Crazy Solution</h2>
<p style="margin-top: -1em;">Step 4: delete temporary memory and return to the call point.</p>

<code style="font-size: 12pt; line-height: 1.25; margin-left: -3em; margin-right: -3em;">void remapToHugeStep3(void * scratch, size_t size, size_t offset)
{
    <span style="color: green">/// The function should not use the stack,
    /// otherwise various optimizations, including "omit-frame-pointer" may break the code.</span>

    <span style="color: green">/// Unmap the scratch area.</span>
    our_syscall(<b>SYS_munmap</b>, scratch, size);

    <span style="color: green">/// The return address of this function is pointing to the scratch area
    /// (because it was called from there).</span>
    <span style="color: green">/// But the scratch area no longer exists.
    /// We should correct the return address by subtracting the offset.</span>

    __asm__ __volatile__("subq %0, 8(%%rsp)" : : "r"(offset) : "memory");
}</code>
    </section>



    <section class="slide">
        <h2>Crazy Solution</h2>

<p style="color: green;">It works.</p>

<p style="margin-top: 2em;">Doesn't work in debug build.</p>
<p style="margin-bottom: 2em;">Doesn't work with sanitizers.</p>

<p>Is there any benefit?</p>
<p>Can it be enabled in production?</p>
    </section>


    <section class="slide">
        <h2>What Did We Actually Do?</h2>
<p>In a very tricky way changed the code segment in memory<br/>
&mdash; so that it starts using <b>Huge Pages</b><br/>
&mdash; hoping to reduce the number of <b>iTLB</b> misses<br/>
&mdash; to reduce false positives in <b>perf-tests in CI</b>.</p>

<p style="line-height: 1.5em;">Result:<br/>
<p>1. Everything works, Huge Pages are actually used.</p>
<p style="color: green;">2. The number of iTLB misses decreased almost to zero!</p>
<p>3. Query execution speed didn't change :(</p>
<p>4. Did perf-test stability improve? &mdash; still unknown.</p>
    </section>

    <section class="slide">
        <h2>Result</h2>
<p>Won't go to production as benefit is not proven and the code is hellish.</p>
<p style="color: green;">Will be enabled in perf tests for verification.</p>

<p style="margin-top: 2em;"><a href="https://github.com/ClickHouse/ClickHouse/pull/14685">https://github.com/ClickHouse/ClickHouse/pull/14685</a></p>
    </section>


    <section class="slide">
        <h2>Conclusions</h2>

<p>Want to optimize something &mdash; first learn to measure.</p>
<p>Be prepared to conduct many experiments,<br/>most of which won't pay off.</p>
<p>Reliable performance tests are hard to make.</p>
<p>Despite having measurements and continuous integration,<br/>consequences of optimizations may only become known in production.</p>
<p>The riskiest optimizations are for specific hardware<br/> and its operational characteristics.</p>

    </section>

    <section class="slide">
        <h2>?</h2>
    </section>

    <div class="progress"></div>
    <script src="shower/shower.js"></script>
</body>
</html>
