<!DOCTYPE html>
<html lang="en">
<head>
    <title>How to Build Portable Binaries for Linux</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:image" content="pictures/preview.jpg">
    <meta property="og:title" content="How to Build Portable Binaries for Linux">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="pictures/preview.jpg">
    <link rel="stylesheet" href="https://presentations.clickhouse.com/shower/themes/clickhouse/styles/styles.css">

    <style>
        code { display: block; white-space: pre; background-color: #EEE; }
    </style>
</head>
<body class="shower list">
    <header class="caption">
        <h1>How to Build Portable Binaries for Linux</h1>
        <p>Author: Alexey Milovidov, 2020-07-01.</p>
    </header>

    <section class="slide" id="cover">
        <h1 style="margin-top: 200px;"><span style="background: rgba(255, 255, 255, 0.75)">How to Build Portable <br/>Binaries for Linux</span></h1>
    </section>

<section class="slide">
<h2>The Problem</h2>
<p>There are many Linux distributions</p>
<p>&mdash; Debian, Ubuntu, Red Hat, CentOS, Fedora, Gentoo, Arch, Suse, Amazon...</p>
<p>There are many versions of each distribution</p>
<p>&mdash; Ubuntu: 25 versions used in production: 8.04 .. 20.04.</p>
<p>Do we need to build our programs for all of them?</p>
</section>

<section class="slide">
<h2>The Problem</h2>
<img style="float: right; height: 60%; margin-right: -80px; margin-top: -100px; margin-left: 0px;" src="pictures/not_optimal.webp"/><p>Do we need to build our programs for all of them?</p>
<p>&mdash; of course not!</p>
<p>&mdash; we don't want to make a hundred build variants<br/>&emsp; and then debug them all.</p>
<p>Let's just build a binary that works on any Linux.</p>
</section>

<section class="slide">
<h2>Let's Try!</h2>
<code style="font-size: 14pt; margin-top: -2em;">#include &lt;vector>
#include &lt;thread>
#include &lt;iostream>

struct S
{
    ~S() { std::cerr &lt;&lt; "Thread exited\n"; }
};

thread_local S s;

int main(int, char **)
{
    std::vector&lt;std::thread> threads;
    for (size_t i = 0; i &lt; 10; ++i)
        threads.emplace_back([]{ std::cerr &lt;&lt; &amp;s &lt;&lt; '\n'; });

    for (auto &amp; thread : threads)
        thread.join();

    return 0;
}</code>
</section>


<section class="slide">
<h2>Let's Try!</h2>
<p>I'll compile a binary on my machine<br/>and run it on a server with Ubuntu 12.04.</p>

<code style="font-size: 14pt; margin-top: 2em;">$ g++ -pthread main.cpp
$ ./a.out

$ docker run -it --rm --volume $(pwd):/test ubuntu:precise /test/a.out

/test/a.out: /usr/lib/x86_64-linux-gnu/libstdc++.so.6:
 version `CXXABI_1.3.7' not found (required by /test/a.out)
/test/a.out: /usr/lib/x86_64-linux-gnu/libstdc++.so.6:
 version `CXXABI_1.3.9' not found (required by /test/a.out)
/test/a.out: /usr/lib/x86_64-linux-gnu/libstdc++.so.6:
 version `GLIBCXX_3.4.22' not found (required by /test/a.out)
</code>
</section>


<section class="slide">
<h2>Let's Figure This Out</h2>
<img style="float: right; width: 40%; margin-top: -60px; margin-right: -50px;" src="pictures/fixing_a_lightbulb.png"/>
<p>1. How are C++ programs built?</p>
<p>2. How do C++ programs work in the OS?</p>
<p>3. How do programs execute on the CPU?</p>
<p style="font-size: 8pt; color: gray; margin-top: 60px; margin-right: -50px; text-align: right;">Malcolm in the Middle S03E06 - Health Scare, Fox Network, 2001</p>
</section>



<section class="slide">
<h2>How C++ Programs are Built</h2>
<code>g++ -pthread main.cpp</code>
<code>g++ <b>-v</b> -pthread main.cpp</code>
<code style="font-size: 12pt; margin-top: 2em;">/usr/lib/gcc/x86_64-linux-gnu/9/collect2
-plugin /usr/lib/gcc/x86_64-linux-gnu/9/liblto_plugin.so
-plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper
-plugin-opt=-fresolution=/tmp/ccKFcsUf.res
-plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc
-plugin-opt=-pass-through=-lpthread -plugin-opt=-pass-through=-lc
-plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc
--build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed
-dynamic-linker /lib64/ld-linux-x86-64.so.2 <b>-pie</b> -z now -z relro
/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/<b>Scrt1.o</b>
/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/<b>crti.o</b>
/usr/lib/gcc/x86_64-linux-gnu/9/<b>crtbeginS.o</b>
-L/usr/lib/gcc/x86_64-linux-gnu/9 -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/9/../../.. /tmp/ccZP10ce.o
<b>-lstdc++ -lm -lgcc_s -lgcc -lpthread -lc -lgcc_s -lgcc</b>
/usr/lib/gcc/x86_64-linux-gnu/9/<b>crtendS.o</b>
/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/<b>crtn.o</b></code>
</section>


<section class="slide" style="font-size: 95%">
<h2 style="font-size: 32pt;">What Libraries are Used Implicitly?</h2>
<p>1. C++ Standard Library</p>
<p>Example implementation: std::string</p>
<p>Different implementations:<br/>
&mdash; <b>libstdc++</b> &mdash; default when building with gcc and clang on Linux;<br/>
&mdash; <b>libc++</b> &mdash; default when building with clang on FreeBSD, Darwin;<br/>
&mdash; you can choose not to use the C++ standard library at all<br/>&emsp; or even write your own.</p>
<p>All variants can be used with both gcc and clang.</p>
<p>You can use different library versions<br/>almost independently of the compiler version:<br/>
&mdash; example: libc++ 11 (master) can be used with clang-10 and gcc-9.3.</p>
</section>


<section class="slide" style="font-size: 95%">
<h2 style="font-size: 32pt;">What Libraries are Used Implicitly?</h2>
<p style="margin-top: -1em;">2. C++ ABI Library</p>
<p>Example implementation: <b>__cxa_throw</b></p>
<p>A layer between the C++ standard library*<br/>and platform-specific implementation of details such as:<br/>
&mdash; exception handling;<br/>
&mdash; RTTI (dynamic_cast and everything around it);<br/>
&mdash; thread_local variables with non-trivial destructors;<br/>
&mdash; static variables in functions with non-trivial initialization;</p>
<p>This library has a C interface, and different C++ standard library implementations use the same C++ ABI interface.</p>
<p>Different implementations:<br/>
&mdash; libstdc++ &mdash; default when building with gcc and clang on Linux;<br/>
&mdash; libc++abi &mdash; default when building with clang on FreeBSD, Darwin;<br/>
&mdash; you can choose not to use exception handling, RTTI...</p>
</section>


<section class="slide" style="font-size: 95%">
<h2 style="font-size: 32pt;">What Libraries are Used Implicitly?</h2>
<p>C++ ABI is not just a library.</p>
<p>It defines data structure layouts, calling conventions, interfaces...</p>
<p>Examples:<br/>
&mdash; how name mangling is done in object files;<br/>
&mdash; where the virtual function table is located and how it's structured;<br/>
&mdash; how exactly to perform exception handling;</p>
<p>If you write in C++, your program uses C++ ABI.</p>
<p>There are different C++ ABIs for different platforms.</p>
<p>For Linux amd64 &mdash; Itanium* C++ ABI.</p>
<p style="font-size: 50%;">* Why is it called that?</p>
</section>


<section class="slide" style="font-size: 95%">
<h2 style="font-size: 32pt;">What Libraries are Used Implicitly?</h2>
<p>The C++ ABI library can use different implementations<br/>of individual details internally.</p>
<p style="margin-top: 1em;">3. Exception Handling Library.</p>
<p>Example implementation: <b>__Unwind_RaiseException</b></p>

<p style="font-size: 70%; color: gray;">C++ ABI defines the exception handling mechanism: which functions are called when handling exceptions, where the data for their operation should be located (location of catch blocks, which destructors to call before getting there...), how this data is encoded in the binary...<br/>The exception handling library implements these mechanisms.</p>

<p>Even for Itanium C++ ABI there are different implementations:<br/>
&mdash; libgcc_eh.a, libgcc_s.so &mdash; default when building with gcc and clang on Linux;<br/>
&mdash; libunwind "nongnu" (HP);<br/>
&mdash; libunwind from LLVM;<br/>
&mdash; you can choose not to use exception handling at all.</p>
</section>


<section class="slide" style="font-size: 95%">
<h2 style="font-size: 32pt;">How are Exceptions Handled?</h2>
<p>Itanium C++ ABI &mdash; "zero-cost exception handling".</p>
<p>If you don't throw exceptions &mdash; it's free*<br/>
* &mdash; well, almost.</p>
<p>Throwing an exception is very expensive (millions of CPU cycles<br/>+ loading cold information from the binary).</p>
<p><a href="https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html">https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html</a><br/>
<a href="https://monoinfinito.wordpress.com/series/exception-handling-in-c/">https://monoinfinito.wordpress.com/series/exception-handling-in-c/</a></p>
<p>ARM, POWER C++ ABI &mdash; also "zero-cost exception handling".</p>
<p>Alternative: SJLJ &mdash; setjmp/longjmp exception handling.<br/>
&mdash; can also be used on amd64 for "self-contained" programs, if exceptions are not thrown between libraries with different EH ABI.</p>
</section>


<section class="slide">
<h2 style="font-size: 32pt;">What Libraries are Used Implicitly?</h2>
<p>The libunwind library can be used not only for exception handling.</p>
<p>You can call its methods manually for stack unwinding and context switching.</p>

<p>And it can also be built in two ways:<br/>
&mdash; with C++ ABI functions;<br/>
&mdash; with different function names so as not to replace the C++ ABI.</p>

<p>You can even use multiple libraries in one program:<br/>
&mdash; libgcc_eh for exception handling according to C++ ABI;<br/>
&mdash; libunwind nongnu for manual stack unwinding.</p>
</section>

<section class="slide">
<h2 style="font-size: 32pt;">What Libraries are Used Implicitly?</h2>
<p style="margin-top: -1em;">4. The libc Library.</p>
<p>Implements completely different things:</p>
<p>&mdash; implementation of the C standard library<br/>&emsp; example: <b>strchr</b>, <b>memcpy</b>, <b>exp</b>;<br/>
&mdash; implementation of POSIX standard functions<br/>&emsp; example: <b>getaddrinfo</b>, <b>pthread_create</b>, <b>dlopen</b>;<br/>
&mdash; wrappers around system calls<br/>&emsp; example: <b>mremap</b>;<br/>
&mdash; and much more...</p>
<p>Different implementations:<br/>
&mdash; <b>glibc</b> &mdash; default when building on Linux;<br/>
&mdash; <b>Musl</b>, DietLibc, UCLibc...<br/>
&mdash; of course, you can choose not to use libc at all :)<br/>
&emsp; (but see <b>-fno-builtin-...</b>)</p>
</section>

<section class="slide">
<h2 style="font-size: 32pt;">What Libraries are Used Implicitly?</h2>
<p style="margin-top: -1em;">5. Compiler builtins / runtime Library.</p>
<p>Implements functionality required for language features or extensions, but separated from the compiler code for implementation on different platforms.</p>
<p>Example: __int128 division: calling the <b>__divti3</b> function;</p>
<p>The interface is compiler-specific. clang and gcc have different,<br/>non-interchangeable compiler builtin libraries.</p>
<p>Implementations:<br/>
&mdash; libgcc_s;<br/>
&mdash; libclang_rt.builtins-x86_64.</p>
<p>Separate libraries for supporting functions<br/>of different build modes: coverage, sanitizers.</p>
</section>

<section class="slide">
<h2 style="font-size: 32pt;">What Libraries are Used Implicitly?</h2>
<p style="margin-top: -1em;">6. Startup Files.</p>
<p>Scrt1.o, crti.o, crtbeginS.o, crtendS.o, crtn.o</p>
<p>Entry point, global initialization.</p>
<p>Example implementation: __start.</p>
<p>Depends on libc and comes with libc distribution.</p>
</section>


<section class="slide">
<h2>Let's Figure This Out</h2>
<p style="color: green;">1. How are C++ programs built?</p>
<p>2. How do C++ programs work in the OS?</p>
<p>3. How do programs execute on the CPU?</p>
</section>

<section class="slide">
<h2 style="font-size: 32pt;">How C++ Programs Work with the OS?</h2>
<p>Actually, any programs... it doesn't matter here.</p>
<p>1. System calls.</p>
<p>2. Signal handlers.</p>
<p>3. Virtual memory mechanism.</p>
<p>...</p>
</section>

<section class="slide">
<h2 style="font-size: 32pt;">How C++ Programs Work with the OS?</h2>
<p>1. System calls.</p>
<code>std::cerr &lt;&lt; "Hello, world\n";</code>
<p>&mdash; C++</p>
<code style="margin-top: 1em;">write(2, "Hello, world\n", 13);</code>
<p>&mdash; Libc, POSIX</p>
<code style="margin-top: 1em;">syscall(SYS_write, 2, "Hello, world\n", 13);</code>
<p>&mdash; Libc</p>
<code style="margin-top: 1em;">__asm__("movq ..., %rax
         ...
         syscall")</code>
</section>

<section class="slide">
<h2 style="font-size: 32pt;">How C++ Programs Work with the OS?</h2>
<p>1. System calls, good facts:</p>
<p>System call numbers in Linux do not change.</p>
<p>Old system calls are not removed and continue to work.</p>
<p>Old behavior of system calls is kept, only new features are added.</p>
<p>Old programs should work on new versions of the Linux kernel (the reverse is not true).</p>
</section>

<section class="slide">
<h2 style="font-size: 32pt;">How C++ Programs Work with the OS?</h2>
<p>2. Signal handlers.</p>
<p>3. Virtual memory mechanism.</p>
<p>Example: page fault causes an interrupt, the OS kernel provides the necessary data for memory mapped files and resumes program execution.</p>
<p>Example: The OS constantly updates the content of the vdso page, which is used by libc functions such as clock_gettime (not always).</p>
<p>Example: page fault causes an interrupt, the OS kernel calls the SEGV signal handler in our program, if it exists.</p>
<p>Puzzle: due to a memory traversal in htop, all other programs suddenly and permanently slowed down.</p>
</section>

<section class="slide">
<h2 style="font-size: 30pt;">How are Programs Built and Run?</h2>
<p>Static linking vs dynamic linking?</p>
<p>Just two options?</p>

<p>No. There are many ways to build your program...<br/><br/>
&mdash; statically linked executable;<br/>
&mdash; dynamically linked executable;<br/>
&mdash; dynamically linked shared object;<br/>
&emsp; &mdash; can use different dynamic loaders (interp);<br/>
&emsp; &mdash; dependencies can be statically linked into the binary<br/>
&emsp; &emsp; or required as dynamic libraries;<br/>
&mdash; additionally, you can load some libraries<br/>&emsp; at runtime using dlopen;</p>
</section>


<section class="slide">
<h2 style="font-size: 30pt;">How do Programs Execute on the CPU?</h2>
<p style="margin-top: -1em;">What instruction set do they use?</p>
<p>amd64 (x86_64):</p>
<p>&mdash; SSE 2 / SSE 3 / SSSE 3 / SSE 4.1 / SSE 4.2<br/> / POPCNT / CLMUL / AVX / AVX 2 / AVX 512...</p>
<p>The instruction set is specified by -m compiler flags,<br/>for example -msse4.2.</p>
<p>You can build separate translation units<br/>with different instruction sets and link them together.</p>
<p>You can build separate functions with different instruction sets:<br/>
__attribute__((target("avx2")))<br/>
_Pragma("GCC target(\"avx2\")"<br/>
__attribute__((ifunc("resolve_func")));</p>
</section>


<section class="slide">
<h2>Now We Know Everything!</h2>
<p style="color: green;">1. How are C++ programs built?</p>
<p style="color: green;">2. How do C++ programs work in the OS?</p>
<p style="color: green;">3. How do programs execute on the CPU?</p>
<p>&nbsp;</p>
<p>How to build portable binaries for Linux?</p>
</section>


<section class="slide">
<h2>Problems</h2>
<code style="font-size: 14pt; margin-top: 2em;">$ g++ -pthread main.cpp
$ ./a.out

$ docker run -it --rm --volume $(pwd):/test ubuntu:precise /test/a.out

/test/a.out: /usr/lib/x86_64-linux-gnu/libstdc++.so.6:
 version `CXXABI_1.3.7' not found (required by /test/a.out)

/test/a.out: /usr/lib/x86_64-linux-gnu/libstdc++.so.6:
 version `CXXABI_1.3.9' not found (required by /test/a.out)

/test/a.out: /usr/lib/x86_64-linux-gnu/libstdc++.so.6:
 version `GLIBCXX_3.4.22' not found (required by /test/a.out)
</code>
</section>

<section class="slide">
<h2>Problems</h2>
<p>Reason: different version of the <b>libstdc++</b> dynamic library<br/> on the target system.</p>
<p>Who said there's even a <b>libstdc++</b> library there?</p>
<p>Who said that installing from the repository<br/> will give you the right version of this library?</p>
<p>What if we want to use <b>libc++</b> instead of <b>libstdc++</b>?</p>
</section>

<section class="slide">
<h2>Problems</h2>
<p>Solution:</p>
<p>Static linking of c++, c++abi libraries into the binary.</p>
<p>The binary itself can remain dynamic and depend on other dynamic libraries.</p>
<p>Potential problems:</p>
<p>If another C++ library is dynamically linked, and this library was compiled with a mismatched version of C++ ABI...
</p>
</section>

<section class="slide">
<h2>Problems</h2>
<p>If another C++ library is dynamically linked, and this library was compiled with a mismatched version of C++ ABI, there are the following options:</p>
<p>1. The program won't build due to differences in symbol names.</p>
<p>2. The program will build but will work incorrectly due to using a different ABI implementation in our binary.<br/>Example: <b>std::terminate</b> when throwing an exception from the library.</p>
<p>3. By some miracle everything will be fine.</p>
</section>

<section class="slide">
<h2>Problems</h2>
<p style="margin-top: -1em;">Solution:</p>
<p><b>All</b> C++ libraries must be built from source with the same build settings and statically linked into the binary.</p>

<p>If there are shared C++ libraries that cannot be rebuilt:<br/>
&mdash; they must have a plain-C interface, all dependencies linked inside, you can't throw exceptions across library boundaries;<br/>
&mdash; you can also avoid linking with the library altogether and move the interaction to a separate process, example: <b>clickhouse-odbc-bridge</b>.<br/>
&mdash; non-working options: RTLD_DEEPBIND, dl<b>m</b>open.
</p>

<p>Conclusion: shared libraries with C++ interfaces should not exist.</p>
</section>

<section class="slide">
<h2>Problems</h2>
<code style="font-size: 14pt; margin-top: 2em;">$ g++ -pthread -static-libstdc++ -static-libgcc main.cpp

$ g++ -nodefaultlibs main.cpp -lstdc++ -lgcc_eh \
    -lgcc -lc -lm -lrt -lpthread -ldl

$ clang++ -std=c++2a -fuse-ld=lld -pthread -nodefaultlibs -nostdinc++ \
    -I ../contrib/libcxx/include/ -I ../contrib/libcxxabi/include/ \
    -L contrib/libcxx-cmake/ -lcxx \
    -L contrib/libcxxabi-cmake/ -lcxxabi \
    -L contrib/libunwind-cmake/ -lunwind \
    -L /usr/lib/clang/9.0.0/lib/linux/ -lclang_rt.builtins-x86_64 \
    -lc -lm -lrt -lpthread -ldl main.cpp
</code>
</section>


<section class="slide">
<h2>Problems</h2>
<code style="font-size: 14pt; margin-top: 2em; margin-bottom: 2em;">$ docker run -it --rm --volume $(pwd):/test ubuntu:precise /test/a.out

/test/a.out: /lib/x86_64-linux-gnu/libc.so.6:
    version `GLIBC_2.18' not found (required by /test/a.out)
</code>
<img style="width: 230px;" src="pictures/frustration.jpg"/>
</section>



<section class="slide">
<h2>Simple Solutions</h2>
<p>Build our program in Docker<br/>and distribute it for use the same way.</p>
<p>Advantages:</p>
<p>&mdash; many are already used to this kind of suffering;</p>
<p>Disadvantages:</p>
<p>&mdash; inconvenient to distribute (example: scp to server doesn't work);<br/>
&mdash; inconvenient to configure system interaction;<br/>
&mdash; inconvenient to debug;</p>
<p>The task of building a portable binary is not solved this way.</p>
</section>

<section class="slide" style="font-size: 95%">
<h2>Simple Solutions</h2>
<p style="margin-top: -1em;">Build our program and supply<br/>all shared libraries with it for installation.</p>
<p>&mdash; change <b>rpath</b> in the binary or make a script<br/>that sets <b>LD_LIBRARY_PATH</b> before launch.<br/>
&mdash; change <b>interp</b> in the binary.</p>
<p><a href="https://github.com/orivej/ldcp">https://github.com/orivej/ldcp</a></p>
<p>Advantages:<br/>
&mdash; it works;</p>
<p>Disadvantages:<br/>
&mdash; inconvenient to distribute (example: scp to server doesn't work);</p>
<p>The task of building a portable binary is not solved this way.</p>
</section>

<section class="slide">
<h2>Simple Solutions</h2>
<p>Build our program as <b>AppImage</b> / <b>Snap</b> / <b>Flatpak</b>.</p>
<p>Advantages:</p>
<p>&mdash; the entire environment is packed into one binary;</p>
<p>Disadvantages:</p>
<p>&mdash; inconvenient to work with the system;<br/>
&mdash; the program takes a long time to start;</p>
<p>More suitable for client applications.</p>
</section>


<section class="slide">
<h2>Problems</h2>
<code style="font-size: 14pt; margin-top: 2em; margin-bottom: 2em;">version `GLIBC_2.18' not found (required by /test/a.out)</code>
<p>How are shared libraries versioned?</p>
<p>Why does our program need this version of GLIBC?</p>
<p>Can we link libc statically?</p>
</section>

<section class="slide">
<h2>Problems</h2>
<p>How are shared libraries versioned?</p>
<p>1. By version number in the name: <b>libc.so.6</b> - libc version 6.</p>
<code style="font-size: 14pt; margin-top: 2em; margin-bottom: 2em;">$ ldd ./a.out
    linux-vdso.so.1 (0x00007ffd639d9000)
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fddc8404000)
    libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007fddc82b5000)
    librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007fddc82aa000)
    libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fddc8287000)
    libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fddc8281000)
    /lib64/ld-linux-x86-64.so.2 (0x00007fddc8619000)</code>
<p>2. By version numbers for individual symbols.</p>
</section>

<section class="slide">
<h2>Problems</h2>
<p>How are shared libraries versioned?</p>
<p>2. By version numbers for individual symbols.</p>
<p>The ability to have multiple implementations of one function with slightly different behavior, so that old programs continue to use the old version for compatibility.</p>
<p>Canonical example: <b>memcpy</b>.</p>
</section>

<section class="slide">
<h2>Problems</h2>
<code style="font-size: 14pt; margin-left: -50px; margin-right: -50px; margin-top: 2em; margin-bottom: 2em;">$ ldd -v ./a.out
Version information:
./a.out:
    libc.so.6 (GLIBC_2.14) => /lib/x86_64-linux-gnu/libc.so.6
    libm.so.6 (GLIBC_2.23) => /lib/x86_64-linux-gnu/libm.so.6

$ readelf -s -V ./a.out | grep -P '2\.(14|23)'
    66: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND memcpy@GLIBC_2.14 (6)
   111: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND lgamma@GLIBC_2.23 (7)
</code>
</section>

<section class="slide">
<h2>Problems</h2>
<p>One-way compatibility:</p>
<p>&mdash; programs built with old symbol versions<br/>&emsp; work on new systems;<br/>
&mdash; programs built with new symbol versions<br/>&emsp; don't work on old systems;</p>
<p>During the build, the newest symbol version is chosen</p>
<p>&mdash; because "that's the right way".</p>
</section>

<section class="slide">
<h2>Solutions That Don't Work</h2>
<p>1. Fully static linking with GLibc.</p>
<p>Just specify <b>-static</b> when building.</p>
<p>&mdash; glibc is built on a <span style="color: red;">complex plugin system</span> that dynamically loads other libraries for DNS lookup, locale conversion, and backtrace. With static linking this functionality is completely disabled and you can't use getaddrinfo.</p>
<p>&mdash; you can't do dlopen from fully static binaries.</p>
<p>Conclusion:<br/>More or less complex programs cannot be statically built with glibc.</p>
</section>

<section class="slide">
<h2>Solutions That Don't Work</h2>
<p>2. Using <b>Musl</b> instead of GLibc.</p>
<p>&mdash; low performance (malloc, memcpy, ...).</p>
<p>&mdash; you can't do dlopen from a fully static binary.</p>
<p>&mdash; when linking a dynamic binary with musl, only the <b>ld-musl.so</b> loader can be used, and you have to carry it with you.</p>
<p>&mdash; due to small differences, some libraries won't build with Musl without patches.</p>
<p>Conclusion:<br/>More or less complex programs are difficult to build with Musl.</p>
</section>

<section class="slide">
<h2>Solutions That Don't Work</h2>
<p>3. Asking the linker to prescribe dependencies<br/>&emsp; on old symbol versions.</p>
<p><a href="https://github.com/wheybags/glibc_version_header">https://github.com/wheybags/glibc_version_header</a></p>
<code style="font-size: 14pt; margin-bottom: 1em;">__asm__(".symver _Exit,_Exit@GLIBC_2.2.5");
__asm__(".symver _IO_2_1_stderr_,_IO_2_1_stderr_@GLIBC_2.2.5");
__asm__(".symver _IO_2_1_stdin_,_IO_2_1_stdin_@GLIBC_2.2.5");
__asm__(".symver _IO_2_1_stdout_,_IO_2_1_stdout_@GLIBC_2.2.5");
...</code>
<p>If you link with this file in the right order,<br/>old symbol versions will be prescribed...</p>
<p>But some symbols that your program depends on<br/>may be completely absent in the old version of libc.</p>
</section>

<section class="slide">
<h2>Solutions That Don't Work</h2>
<p>4. Patch the binary after building,<br/>replacing symbol versions with weak ones.</p>
<p><a href="http://www.lightofdawn.org/wiki/wiki.cgi/NewAppsOnOldGlibc">http://www.lightofdawn.org/wiki/wiki.cgi/NewAppsOnOldGlibc</a></p>
<p>Doesn't work for the same reason as the previous method.</p>
</section>

<section class="slide">
<h2>Solutions That Don't Work</h2>
<p>5. Building with an old version of libc.</p>
<p>&mdash; in an old system in <b>Docker</b>;<br/>
&emsp; you'll need to bring a new compiler there... and make it work;</p>
<p>&mdash; in <b>chroot</b>;</p>
<p>&mdash; just <b>-nodefaultlibs</b> and explicitly specify the path<br/>&emsp; to a sufficiently old version of libc;</p>
<p>&mdash; variant &mdash; <b>-sysroot</b>, CMake Toolchain.</p>
</section>

<section class="slide">
<h2>Solutions That Don't Work</h2>
<p>5. Building with an old version of libc.</p>
<p>Bad because you'll get old, inefficient code.</p>
<p>Doesn't work because the old version is missing some things:</p>
<code style="margin-bottom: 1em;">__cxa_thread_atexit_impl</code>
<p>You can't just build a C++11 program<br/>with an old version of libc.</p>
<p>And we're already using C++20 :)</p>
</section>


<section class="slide">
<h2>A Solution That Works</h2>
</section>

<section class="slide">
<h2>A Solution That Works</h2>
<p>To build portable binaries for Linux, you just need to...</p>
<p>1. Build libc++, libc++abi, libunwind from source<br/>&emsp; and link statically.</p>
<p>2. Build all third-party libraries except libc from source<br/>&emsp; and link statically.</p>
<p>3. Use separate allocator implementations<br/>&emsp; instead of libc (jemalloc / tcmalloc).</p>
<p>4. Use a separate memcpy implementation<br/>&emsp; instead of libc (ours is "Chinese" memcpy).</p>
<p>5. Use fixed libc header files (-nostdinc).</p>
</section>

<section class="slide">
<h2>A Solution That Works</h2>
<p>6. Take all functions that have too new versions in glibc<br/>&emsp; from Musl, put them in a separate library and link before glibc.</p>
<p>7. Take all functions that are missing in old glibc versions<br/>&emsp; from Musl and put them there too.</p>
<p>8. Configure third-party libraries so they don't have<br/>&emsp; dependencies on too new libc functions (C11 threads)<br/>&emsp; and too new Linux kernel features.</p>
<p>9. Our binary still remains a dynamically linked executable,<br/>&emsp; but depends only on libc and doesn't depend on new symbol versions.</p>
<p>10. We can still do dlopen, but very carefully.</p>
</section>

<section class="slide">
<h2>A Solution That Works</h2>
<p>11. Compile all code with a sufficiently old instruction set<br/>
(SSE 4.2 for ClickHouse), and individual functions and translation units<br/>
&mdash; with newer ones.</p>
<p>Choose the appropriate implementation at runtime<br/>using cpuid checks.</p>
</section>

<section class="slide">
<h2>A Solution That Works</h2>
<p>Just link a piece from Musl statically into the program,<br/>and then GLibc dynamically???</p>
<img style="float: right; width: 200px; margin-right: -50px;" src="pictures/magic.webp" />
<p style="color: green;"><b>... it works.</b></p>

<p>A single clickhouse binary is built on any Linux,<br/>works the same on Ubuntu 8.04+, CentOS 5+ (12 years), GosLinux, etc...</p>
<p>+ builds and tests with any build options and all sanitizers.</p>
<p>+ simple cross-compilation on Linux amd64 for<br/>&ensp; Linux AArch64, FreeBSD and Darwin.</p>

<p style="font-size: 8pt; color: gray;">Image: Pusheen the cat, Claire Belton, 2010; Aura, Telegram sticker.</p>
</section>


<section class="slide">
<h2>Where to Look</h2>
    <p><a href="https://github.com/ClickHouse/ClickHouse/tree/master/base/glibc-compatibility">https://github.com/ClickHouse/ClickHouse/tree/master/<br/>&ensp;base/glibc-compatibility</a><br/>
    &mdash; library with functions to replace glibc symbols.</p>

    <p><a href="https://github.com/ClickHouse/ClickHouse/blob/master/cmake/linux/default_libs.cmake">https://github.com/ClickHouse/ClickHouse/blob/master/<br/>&ensp;cmake/linux/default_libs.cmake</a><br/>
    &mdash; how to describe the build in CMake (complicated).</p>

    <p><a href="https://clickhouse-builds.s3.yandex.net/12043/15cddc3c6e659cec18f4b16f7fc4cd3b3b36a1cb/clickhouse_build_check/report.html">https://clickhouse-builds.s3.yandex.net/<br/>&ensp;12043/15cddc3c6e659cec18f4b16f7fc4cd3b3b36a1cb/<br/>&ensp;clickhouse_build_check/report.html</a><br/>
    &mdash; builds on every commit, build logs.</p>
</section>


    <section class="slide">
        <h2>.</h2>
    </section>

    <div class="progress"></div>
    <script src="https://presentations.clickhouse.com/shower/shower.js"></script>
<footer class="badge">
    <a href="https://presentations.clickhouse.com/">ClickHouse Theater</a>
</footer>
</body>
</html>
