<!DOCTYPE html>
<html lang="en">
<head>
    <title>Zero-Cost Abstractions Using Hash Tables in ClickHouse as an Example</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:image" content="pictures/preview.jpg">
    <meta property="og:title" content="Zero-Cost Abstractions Using Hash Tables in ClickHouse as an Example">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="pictures/preview.jpg">
    <link rel="stylesheet" href="https://presentations.clickhouse.com/shower/themes/clickhouse/styles/styles.css">
</head>
<body class="shower list">
    <header class="caption">
        <h1>Zero-Cost Abstractions Using Hash Tables in ClickHouse as an Example</h1>
        <p>Author: Maksim Kita, 2021-05-11.</p>
    </header>

    <section class="slide" id="cover" style="background: #FFF url('pictures/title.png') no-repeat; background-size: 100%;">
        <h1 style="margin-top: 50px; font-size: 32pt; color: white;">Zero-Cost Abstractions Using Hash Tables in ClickHouse as an Example</h1>
    </section>

    <section class="slide">
        <h2>Hash Tables</h2>
        <p>1. Introduction to hash tables.</p>
        <p>2. Main design questions.</p>
        <p>3. Benchmarks.</p>
        <p>4. C++ hash table design.</p>
    </section>

    <section class="slide">
        <h2>Hash Tables in ClickHouse</h2>
        <p>GROUP BY</p>
        <p>JOIN</p>
        <p>SELECT DISTINCT</p>
    </section>

    <section class="slide">
        <h2>Hash Table</h2>
        <p>Main methods
            <ul>
                <li>lookup O(1) average</li>
                <li>insert O(1) average</li>
                <li>erase O(1) average (Not very important for our scenarios)</li>
            </ul>
        </p>
    </section>

    <section class="slide">
        <h2>Hash Table</h2>
        <img style="text-align: center; height:60%; margin-left: 150px;" src="pictures/hash_table_overview_1.png"/>
    </section>

    <section class="slide">
        <h2>Hash Table Components</h2>
        <p>1. Hash function.</p>
        <p>2. Collision resolution method.</p>
        <p>3. Resize.</p>
        <p>4. Cell memory layout.</p>
    </section>

    <section class="slide">
        <h2>Choosing Hash Function</h2>
        <p>1. Don't use identity function for integer types.</p>
        <p>2. Don't use hash functions for strings (CityHash) for integer types.</p>
        <p>3. Don't use cryptographic hash functions if you're not under attack. For example, SipHash calculation ~980 MB/s. CityHash ~9 GB/s.</p>
        <p>4. Don't use outdated hash functions. FNV1a.</p>

        <p>
            <a style="font-size: 15px;" href="https://github.com/rurban/smhasher">
                https://github.com/rurban/smhasher
            </a>
        </p>
    </section>

    <section class="slide">
        <h2>Choosing Hash Function</h2>
        <p>By default ClickHouse uses bad hash functions.</p>
        <p>1. CRC32-C for integer types. One processor instruction (actually two) latency 3 cycles.</p>
        <p>2. Special hash function for strings. Can use CityHash, xxHash, wyhash as standard.</p>
    </section>

    <section class="slide">
        <h2>Collision Resolution</h2>
        <img style="height:75%; margin-left: 150px; margin-top: -50px;" src="pictures/hash_table_collision.png"/>
    </section>

    <section class="slide">
        <h2>Collision Resolution</h2>
        <p>1. Chaining.</p>
        <p>2. Open Addressing.</p>
        <p>3. Good in theory (Cuckoo hashing, Hopscotch hashing, 2-choice hashing). Usually either hard to implement,
            or slow due to additional memory fetches.</p>
    </section>

    <section class="slide">
        <h2>Chaining</h2>

        <img style="height:75%; margin-left: 150px; margin-top: -50px;" src="pictures/hash_table_collision_chaining.png"/>
    </section>

    <section class="slide">
        <h2>Chaining</h2>

        <p>Example: std::unordered_map</p>

        <p>1. Pointer stability for key, value.</p>
        <p>2. Ability to store large objects, non-movable objects.</p>
        <p>3. Works well with bad hash function, high load factor.</p>
        <p>4. Very slow. Stresses allocator (even just calling function is expensive for hot path).</p>
        </li>
    </section>

    <section class="slide">
        <h2>Open Addressing</h2>

        <img style="height:75%; margin-left: 125px; margin-top: -50px;" src="pictures/hash_table_collision_open_addressing.png"/>
    </section>

    <section class="slide">
        <h2>Open Addressing</h2>
        <p>Linear probing. Example: ClickHouse HashMap.</p>
        <p>Quadratic probing. Example: Google DenseHashMap.</p>
        <p>1. Good cache locality.</p>
        <p>2. Need to carefully choose hash function.</p>
        <p>3. Can't store large objects. Serialize to arena and store pointers to them.</p>
    </section>

    <section class="slide">
        <h2>Resize</h2>
        <p>1. By powers of two. Fast modulo division.</p>
        <code style="display: block; white-space: pre; font-size: 19px;">size_t place = hash & (size - 1)</code>
        <br>
        <p>2. To a prime number close to power of two. Slow division even with constant switch, libdivide but there's also fastrange.</p>
    </section>

    <section class="slide">
        <h2>Choosing Load Factor</h2>
        <p>0.5 is a good choice for linear probing with step 1.</p>
        <p>ClickHouse HashMap, Google DenseHashMap uses 0.5.</p>
        <p>Abseil HashMap uses 0.875.</p>
        <p></p>
    </section>

    <section class="slide">
        <h2>Memory Layout</h2>
        <img style="height:75%; margin-left: 125px; margin-top: -50px;" src="pictures/hash_table_layout.png"/>
    </section>

    <section class="slide">
        <h2>Memory Layout</h2>
        <p>Ask client to choose keys for empty and deleted values.</p>
        <img style="margin-left: 175px; height:60%" src="pictures/hash_table_layout_sentinels.png"/>
    </section>

    <section class="slide">
        <h2>Memory Layout</h2>
        <p>Handle empty value separately and don't store it in hash table.</p>
        <img style="margin-left: 175px; height:55%" src="pictures/hash_table_layout_null_special.png"/>
    </section>

    <section class="slide">
        <h2>Memory Layout</h2>
        <p>Compressed storage of metadata and data.</p>
        <img style="margin-left: 160px; height:60%" src="pictures/hash_table_metadata.png"/>
    </section>

    <section class="slide">
        <h2>Benchmarks</h2>

        <div>
            <img style="height:60%; position: absolute; margin-left: 200px;" src="pictures/hash_table_benchmarks_1.png"/>
            <img style="height:40%; position: absolute; margin-top: 50px;" src="pictures/hash_table_benchmarks_2.png"/>
            <img style="height:60%; position: absolute; opacity: 0.8; margin-left: 200px; margin-top: -50px" src="pictures/hash_table_benchmarks_3.png"/>
            <img style="height:40%; position: absolute; opacity: 0.8; margin-left: 150px;" src="pictures/hash_table_benchmarks_4.png"/>
        </div>
    </section>

    <section class="slide">
        <h2>How NOT to Do Benchmarks</h2>
        <p>Test hash tables on random integer values.</p>
        <p>Test hash tables without accounting for maximum load factor, memory consumption.</p>
        <p>Test and not show benchmark code.</p>
    </section>

    <section class="slide">
        <h2>How to Do Benchmarks</h2>
        <p>On real scenarios and real data. In ClickHouse the real scenario is data aggregation.</p>
        <p>Yandex.Metrica dataset.</p>
        <p style="font-size: 19px;">wget https://datasets.clickhouse.com/hits/partitions/hits_100m_obfuscated_v1.tar.xz</p>
    </section>

    <section class="slide">
        <h2>Benchmarks</h2>
            <p>WatchID almost all values are unique. Hash table size 20714865 elements. This is ~600 MB, doesn't fit in LL caches.

                <table style="margin-top: -15px; font-size: 19px;">
                    <tr><td>ClickHouse HashMap: </td><td>7.366 sec.</td></tr>
                    <tr><td>Google DenseMap: </td><td>10.089 sec.</td></tr>
                    <tr><td>Abseil HashMap: </td><td>9.011 sec.</td></tr>
                    <tr><td>std::unordered_map: </td><td>44.758 sec.</td></tr>
                </table>
            </p>

            <p>Deinitialization of std::unordered_map took longer than benchmarks of other tables.</p>
    </section>

    <section class="slide">
        <h2>Benchmarks</h2>
        <code style="font-size: 19px;">perf stat -e cache-misses:u ./integer_hash_tables_and_hashes</code>

        <table style="font-size: 19px;">
            <tr><td>ClickHouse HashMap: </td><td>329,664,616</td></tr>
            <tr><td>Google DenseMap: </td><td>383,350,820</td></tr>
            <tr><td>Abseil HashMap: </td><td>415,869,669</td></tr>
            <tr><td>std::unordered_map: </td><td>1,939,811,017</td></tr>
        </table>
    </section>

    <section class="slide">
        <h2>Benchmarks</h2>
        <pre style="font-size: 19px;">
Latency Comparison Numbers
----------------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns 14x L1 cache
Mutex lock/unlock                           25   ns
Main memory reference                      100   ns <b>20x L2 cache, 200x L1 cache</b>
Compress 1K bytes with Zippy             3,000   ns        3 us
Send 1K bytes over 1 Gbps network       10,000   ns       10 us
Read 4K randomly from SSD*             150,000   ns      150 us ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
</pre>

    <p>
        <a style="font-size: 15px;" href="http://norvig.com/21-days.html#answers">
            http://norvig.com/21-days.html#answers
        </a>
    </p>
    </section>

    <section class="slide">
        <h2>Benchmarks</h2>
        <p>RegionID frequently repeating values. Hash table size 9040 elements. Fits in LL caches.

            <table style="margin-top: -15px; font-size: 19px;">
                <tr><td>ClickHouse HashMap: </td><td>0.201 sec.</td></tr>
                <tr><td>Google DenseMap: </td><td> 0.261 sec.</td></tr>
                <tr><td>Abseil HashMap: </td><td>0.307 sec.</td></tr>
                <tr><td>std::unordered_map: </td><td>0.466 sec.</td></tr>
            </table>
        </p>
    </section>

    <section class="slide">
        <h2>C++ Hash Table Design</h2>
        <p>1. Hash</p>
        <p>2. Allocator</p>
        <p>3. Cell</p>
        <p>4. Grower (resize interface)</p>
        <p>5. HashTable</p>
    </section>

    <section class="slide">
        <h2>C++ Hash Table Design</h2>
        <p>Hash</p>
        <p>Same as std::hash.</p>
        <code style="display: block; white-space: pre; font-size: 18px;">template &lt;typename T&gt;
struct Hash
{
    size_t operator() (T key) const
    {
        return DefaultHash&lt;T&gt;(key);
    }
};</code>
    </section>

    <section class="slide">
        <h2>C++ Hash Table Design</h2>
        <p>Allocator</p>
        <p>Uses mmap, mremap for large chunks of memory.</p>
        <code style="display: block; white-space: pre; font-size: 18px;">class Allocator
{
    void * alloc(size_t size, size_t alignment);

    void free(void * buf, size_t size);

    void * realloc(void * buf, size_t old_size, size_t new_size);
};
</code>
        <p>There is an allocator that initially allocates memory on stack:</p>
        <code style="display: block; white-space: pre; font-size: 18px;">AllocatorWithStackMemory&lt;HashTableAllocator, initial_bytes&gt;
</code>
    </section>

    <section class="slide">
        <h2>C++ Hash Table Design</h2>
        <p>Cell</p>
        <code style="display: block; white-space: pre; font-size: 18px;">template &lt;typename Key, typename Mapped, typename HashTableState&gt;
struct HashTableCell
{
    ...

    void setHash(size_t hash_value);

    size_t getHash(const Hash & hash) const;

    bool isZero(const State & state);

    void setZero();
    ...
};</code>
    </section>

    <section class="slide">
        <h2>C++ Hash Table Design</h2>
        <p>Grower</p>
        <code style="display: block; white-space: pre; font-size: 18px;">struct HashTableGrower
{
    size_t place(size_t x) const;

    size_t next(size_t pos) const;

    bool willNextElementOverflow() const;

    void increaseSize();

};</code>
    </section>

    <section class="slide">
        <h2>C++ Hash Table Design</h2>
        <p>HashTable</p>
        <code style="display: block; white-space: pre; font-size: 18px;">template
&lt;
    typename Key,
    typename Cell,
    typename Hash,
    typename Grower,
    typename Allocator
&gt;
class HashTable :
    protected Hash,
    protected Allocator,
    protected Cell::State;
    protected ZeroValueStorage&lt;Cell::need_zero_value_storage, Cell&gt;
        </code>

    </section>

    <section class="slide">
        <h2>C++ Hash Table Design</h2>
        <p>ZeroValueStorage</p>
        <code style="display: block; white-space: pre; font-size: 18px;">template &lt;bool need_zero_value_storage, typename Cell&gt;
struct ZeroValueStorage;

template &lt;typename Cell&gt;
struct ZeroValueStorage&lt;true, Cell&gt;
{
    ...
};

template &lt;typename Cell&gt;
struct ZeroValueStorage&lt;false, Cell&gt;
{
    ...
};
</code>

    </section>


    <section class="slide">
        <h2>C++ Hash Table Design</h2>
        <p>Ability to pass custom Grower.</p>
        <p>1. Pass Grower with fixed size, without resize and collision resolution chains we get a Lookup table.</p>
        <p>2. Pass Grower with collision resolution step not 1.</p>
    </section>

    <section class="slide">
        <h2>C++ Hash Table Design</h2>
        <p>Ability to store state in cell.</p>
        <p>Save hash. Used for string hash tables.</p>

        <code style="display: block; white-space: pre; font-size: 18px;">struct HashMapCellWithSavedHash : public HashMapCell
{
    size_t saved_hash;

    void setHash(size_t hash_value) { saved_hash = hash_value; }

    size_t getHash(const Hash &) const { return saved_hash; }
};</code>
    </section>

    <section class="slide">
        <h2>C++ Hash Table Design</h2>
        <p>Fast-clearable hash table.</p>

        <code style="display: block; white-space: pre; font-size: 18px;">struct FixedClearableHashMapCell
{
    struct ClearableHashSetState
    {
        UInt32 version = 1;
    };

    using State = ClearableHashSetState;

    UInt32 version = 1;

    bool isZero(const State & st) const { return version != st.version; }

    void setZero() { version = 0; }
};
</code>
    </section>

    <section class="slide">
        <h2>C++ Hash Table Design</h2>
        <p>LRUCache.</p>

        <code style="display: block; white-space: pre; font-size: 18px;">struct LRUHashMapCell
{
    static bool constexpr need_to_notify_cell_during_move = true;

    static void move(LRUHashMapCell * old_loc, LRUHashMapCell * new_loc);

    LRUHashMapCell * next = nullptr;

    LRUHashMapCell * prev = nullptr;
};
</code>
    </section>

    <section class="slide">
        <h2>C++ Hash Table Design</h2>
        <p>LRUCache. Use boost::intrusive::list.</p>

        <code style="display: block; white-space: pre; font-size: 18px;">using LRUList = boost::intrusive::list
    &lt;
        Cell,
        boost::intrusive::value_traits&lt;LRUHashMapCellIntrusiveValueTraits&gt;,
        boost::intrusive::constant_time_size&lt;false&gt;
    &gt;;

LRUList lru_list;
    </code>
    <p style="margin-top: 140px;">
        <a style="font-size: 15px;" href="https://www.boost.org/doc/libs/1_76_0/doc/html/intrusive.html">
            https://www.boost.org/doc/libs/1_76_0/doc/html/intrusive.html
        </a>
    </p>
    </section>

    <section class="slide">
        <h2>Specialized Hash Tables</h2>
        <p>SmallTable</p>
        <p>Consists of an array for some small number of elements. Fits in L1 cache.</p>

<code style="display: block; white-space: pre; font-size: 18px;">template &lt;typename Key, typename Cell, size_t capacity&gt;
class SmallTable : protected Cell::State
{
    size_t m_size = 0;
    Cell buf[capacity];
    ...
}
</code>
    </section>

    <section class="slide">
        <h2>Specialized Hash Tables</h2>
        <p>StringHashTable</p>
        <p>Consists of 4 hash tables:</p>
        <p>1. For strings of size 0-8 bytes.</p>
        <p>2. For strings of size 9-16 bytes.</p>
        <p>3. For strings of size 17-24 bytes.</p>
        <p>4. For strings larger than 24 bytes.</p>

        <p>
            <a style="font-size: 15px;" href="https://www.researchgate.net/publication/339879042_SAHA_A_String_Adaptive_Hash_Table_for_Analytical_Databases">
                https://www.researchgate.net/publication/339879042_SAHA_A_String_Adaptive_Hash_Table_for_Analytical_Databases
            </a>
        </p>
    </section>

    <section class="slide">
        <h2>Specialized Hash Tables</h2>
        <p>TwoLevelHashTable</p>
        <p>Consists of 256 hash tables:</p>
        <p>On key insert we calculate the hash table index where we will insert the key.</p>
        <code style="display: block; white-space: pre; font-size: 19px;">size_t getBucketFromHash(size_t hash_value)
{
    return (hash_value >> (32 - BITS_FOR_BUCKET)) & MAX_BUCKET;
}</code>
    </section>

    <section class="slide">
        <h2>Conclusion</h2>
        <p>We wrote a framework for hash tables for our data aggregation scenario.</p>
        <p>
            <a style="font-size: 15px;" href="https://github.com/ClickHouse/ClickHouse/blob/master/src/Common/HashTable/HashMap.h">
                https://github.com/ClickHouse/ClickHouse/blob/master/src/Common/HashTable/HashTable.h
            </a>
            <a style="font-size: 15px;" href="https://github.com/ClickHouse/ClickHouse/blob/master/src/Common/examples/integer_hash_tables_benchmark.cpp">
                https://github.com/ClickHouse/ClickHouse/blob/master/src/Common/examples/integer_hash_tables_benchmark.cpp
            </a>
        </p>
    </section>

    <section class="slide">
        <h2>Thank you!</h2>
    </section>

    <div class="progress"></div>
    <script src="https://presentations.clickhouse.com/shower/shower.js"></script>

    <!--Video plugin-->
    <link rel="stylesheet" href="https://presentations.clickhouse.com/shower/shower-video.css">
    <script src="https://presentations.clickhouse.com/shower/shower-video.js"></script>
    <!--/Video plugin-->
<footer class="badge">
    <a href="https://presentations.clickhouse.com/">ClickHouse Theater</a>
</footer>
</body>
</html>
